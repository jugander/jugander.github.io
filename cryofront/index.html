<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cryofront</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 36'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%2300cfd8'/%3E%3Cstop offset='100%25' stop-color='%230088a0'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cg stroke='url(%23g)' stroke-linecap='round' fill='none'%3E%3Cg stroke-width='2.2'%3E%3Cline x1='16' y1='3' x2='16' y2='14'/%3E%3Cline x1='16' y1='3' x2='13' y2='6.5'/%3E%3Cline x1='16' y1='3' x2='19' y2='6.5'/%3E%3Cline x1='4.7' y1='9.5' x2='14' y2='14.9'/%3E%3Cline x1='4.7' y1='9.5' x2='5.8' y2='13.6'/%3E%3Cline x1='4.7' y1='9.5' x2='8.8' y2='9.2'/%3E%3Cline x1='27.3' y1='9.5' x2='18' y2='14.9'/%3E%3Cline x1='27.3' y1='9.5' x2='23.2' y2='9.2'/%3E%3Cline x1='27.3' y1='9.5' x2='26.2' y2='13.6'/%3E%3Cline x1='4.7' y1='22.5' x2='14' y2='17.1'/%3E%3Cline x1='4.7' y1='22.5' x2='8.8' y2='22.8'/%3E%3Cline x1='4.7' y1='22.5' x2='5.8' y2='18.4'/%3E%3Cline x1='27.3' y1='22.5' x2='18' y2='17.1'/%3E%3Cline x1='27.3' y1='22.5' x2='23.2' y2='22.8'/%3E%3Cline x1='27.3' y1='22.5' x2='26.2' y2='18.4'/%3E%3C/g%3E%3Cg stroke-width='2.8'%3E%3Cline x1='16' y1='18' x2='16' y2='34'/%3E%3Cline x1='16' y1='34' x2='11.8' y2='29'/%3E%3Cline x1='16' y1='34' x2='20.2' y2='29'/%3E%3Cline x1='16' y1='27' x2='12.8' y2='24'/%3E%3Cline x1='16' y1='27' x2='19.2' y2='24'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E">
<meta name="description" content="The Pareto frontier of sustained cold — explore minimax temperature curves by city or ZIP code.">
<meta name="theme-color" content="#0088a0">
<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="Cryofront">
<meta property="og:description" content="The Pareto frontier of sustained cold — explore minimax temperature curves by city or ZIP code.">
<meta property="og:image" content="https://jugander.github.io/cryofront/og-image.png">
<meta property="og:url" content="https://jugander.github.io/cryofront/">
<!-- Twitter / Bluesky -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Cryofront">
<meta name="twitter:description" content="The Pareto frontier of sustained cold — explore minimax temperature curves by city or ZIP code.">
<meta name="twitter:image" content="https://jugander.github.io/cryofront/og-image.png">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* --- Theme variables --- */

:root {
  --bg: #1a1a2e;
  --bg-card: #16213e;
  --text: #e0e0e0;
  --text-heading: #f0f0f0;
  --text-muted: #888;
  --text-card: #aaa;
  --text-card-strong: #ccc;
  --input-bg: #16213e;
  --input-border: #333;
  --input-text: #f0f0f0;
  --input-placeholder: #666;
  --accent: #00adb5;
  --accent-hover: #00c9d4;
  --footer-text: #666;
  --footer-link: #888;
  --footer-link-hover: #aaa;
  --spinner-color: #f0c040;
  --status-loading: #f0c040;
  --status-error: #ff6b6b;
  --location-color: #e8e8e8;
}

html.light {
  --bg: #f4f4f8;
  --bg-card: #ffffff;
  --text: #333;
  --text-heading: #1a1a2e;
  --text-muted: #777;
  --text-card: #666;
  --text-card-strong: #444;
  --input-bg: #ffffff;
  --input-border: #ccc;
  --input-text: #333;
  --input-placeholder: #999;
  --accent: #0088a0;
  --accent-hover: #006a7d;
  --footer-text: #999;
  --footer-link: #777;
  --footer-link-hover: #555;
  --spinner-color: #c89b00;
  --status-loading: #b08800;
  --status-error: #d33;
  --location-color: #222;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

#app {
  max-width: 920px;
  margin: 0 auto;
  padding: 2rem 1rem;
}

header {
  text-align: center;
  margin-bottom: 2rem;
  position: relative;
}

header h1 {
  font-size: 2.2rem;
  font-weight: 300;
  letter-spacing: 0.05em;
  color: var(--text-heading);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.45rem;
}

.logo-icon {
  width: 1.6em;
  height: 1.6em;
  flex-shrink: 0;
}

header .subtitle {
  margin-top: 0.4rem;
  font-size: 0.9rem;
  color: var(--text-muted);
  font-style: italic;
}

/* --- Slide toggles --- */

.slide-toggle {
  display: inline-flex;
  align-items: center;
  border: 1px solid var(--input-border);
  border-radius: 20px;
  background: var(--input-bg);
  cursor: pointer;
  padding: 2px;
  position: relative;
  transition: border-color 0.2s, background 0.3s;
  user-select: none;
}

.slide-toggle:hover { border-color: var(--accent); }

.slide-toggle .opt {
  position: relative;
  z-index: 1;
  padding: 0.25rem 0.55rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  transition: color 0.25s;
  line-height: 1;
}

.slide-toggle .opt.active { color: var(--text-heading); }

.slide-toggle .slider {
  position: absolute;
  top: 2px;
  bottom: 2px;
  border-radius: 16px;
  background: var(--accent);
  opacity: 0.25;
  transition: left 0.25s ease, width 0.25s ease;
  pointer-events: none;
}

#theme-toggle-wrap {
  position: absolute;
  top: 0;
  right: 0;
}

/* --- Input --- */

#zip-form {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

#checkbox-row {
  flex-basis: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.75rem;
}

#loc-wrap {
  position: relative;
}

#loc-input {
  width: 240px;
  padding: 0.6rem 1rem;
  font-size: 1rem;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  color: var(--input-text);
  outline: none;
  transition: border-color 0.2s, background 0.3s, color 0.3s;
}

#loc-input:focus {
  border-color: var(--accent);
}

#loc-input::placeholder {
  color: var(--input-placeholder);
}

#zip-form label {
  font-size: 0.82rem;
  font-weight: 600;
  color: var(--text-muted);
  white-space: nowrap;
}

#lastk-label {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

#lastk-label input {
  margin: 0;
  accent-color: var(--accent);
}

#incl-current-label {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

#incl-current-label input {
  margin: 0;
  accent-color: var(--accent);
}

#incl-today-label {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

#incl-today-label input {
  margin: 0;
  accent-color: var(--accent);
}

#loc-suggestions {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 4px;
  list-style: none;
  background: var(--bg-card);
  border: 1px solid var(--input-border);
  border-radius: 8px;
  overflow: hidden;
  z-index: 10;
  box-shadow: 0 4px 16px rgba(0,0,0,0.25);
}

#loc-suggestions li {
  padding: 0.5rem 0.8rem;
  font-size: 0.88rem;
  color: var(--text);
  cursor: pointer;
  transition: background 0.15s;
}

#loc-suggestions li:hover,
#loc-suggestions li.active {
  background: var(--accent);
  color: #fff;
}

#loc-suggestions li .loc-sub {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-left: 0.3rem;
}

#loc-suggestions li:hover .loc-sub,
#loc-suggestions li.active .loc-sub {
  color: rgba(255,255,255,0.7);
}

#go-btn {
  padding: 0.6rem 1.4rem;
  font-size: 1rem;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  transition: background 0.2s, opacity 0.2s;
}

#go-btn:hover { background: var(--accent-hover); }
#go-btn:disabled { opacity: 0.4; cursor: not-allowed; }


/* --- Status --- */

#status-area {
  text-align: center;
  min-height: 1.4rem;
  font-size: 0.9rem;
  margin-bottom: 1rem;
}

#status-area.loading { color: var(--status-loading); }
#status-area.error { color: var(--status-error); }

.spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--spinner-color);
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.7s linear infinite;
  vertical-align: middle;
  margin-right: 0.4rem;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* --- Chart --- */

#chart-container {
  background: var(--bg-card);
  border-radius: 12px;
  padding: 1.5rem 1rem 1rem;
  margin-top: 0.5rem;
  transition: background 0.3s;
}

#location-name {
  text-align: center;
  font-size: 1.3rem;
  font-weight: 400;
  color: var(--location-color);
  margin-bottom: 1rem;
}

#chart-wrapper {
  position: relative;
  width: 100%;
}

/* --- Chart legend --- */

#chart-legend {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 0.1rem 0.7rem;
  margin-top: 0.5rem;
  padding: 0 0.5rem;
}

#chart-legend .leg-item {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.68rem;
  color: var(--text-muted);
  opacity: 0.7;
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}

#chart-legend .leg-item:hover {
  opacity: 1;
}

#chart-legend .leg-item.pinned {
  opacity: 1;
  font-weight: 600;
}

#chart-legend .leg-swatch {
  width: 14px;
  height: 3px;
  border-radius: 1px;
}

#chart-legend .leg-item.current .leg-swatch {
  height: 4px;
}

#chart-legend .leg-item.pinned .leg-swatch {
  height: 5px;
}

/* When pins are active, dim unpinned items — including .current */
#chart-legend.has-pins .leg-item:not(.pinned) {
  opacity: 0.35;
  font-weight: 400;
}

#chart-legend.has-pins .leg-item:not(.pinned) .leg-swatch {
  height: 3px;
}

#chart-legend.grid-mode {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 0px 0.55rem;
  margin-top: 0.4rem;
  padding: 0 0.25rem;
  line-height: 1.25;
}

#chart-legend.grid-mode .leg-cell {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  font-size: 0.68rem;
  color: var(--text-muted);
  cursor: pointer;
  opacity: 0.65;
  transition: opacity 0.15s;
  user-select: none;
}

#chart-legend.grid-mode .leg-cell .leg-dot {
  width: 8px;
  height: 8px;
  border-radius: 1px;
  flex-shrink: 0;
}

#chart-legend.grid-mode .leg-cell:hover {
  opacity: 1;
}

#chart-legend.grid-mode .leg-cell.pinned {
  opacity: 1;
  font-weight: 700;
}

#chart-legend.grid-mode .leg-cell.pinned .leg-dot {
  outline: 1.5px solid var(--text);
  outline-offset: 0.5px;
}

#chart-legend.grid-mode .leg-cell.current {
  opacity: 1;
  font-weight: 700;
}

#chart-legend.grid-mode .leg-cell.current .leg-dot {
  outline: 1.5px solid var(--accent);
  outline-offset: 0.5px;
}

/* When pins are active, dim unpinned cells — including .current */
#chart-legend.grid-mode.has-pins .leg-cell:not(.pinned) {
  opacity: 0.35;
  font-weight: 400;
}

#chart-legend.grid-mode.has-pins .leg-cell:not(.pinned) .leg-dot {
  outline: none;
}

#export-btn {
  display: block;
  margin: 0.5rem auto 0;
  padding: 0.25rem 0.65rem;
  font-size: 0.72rem;
  border: 1px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text-muted);
  cursor: pointer;
  opacity: 0.45;
  transition: opacity 0.2s, border-color 0.2s;
}
#export-btn:hover { opacity: 1; border-color: var(--accent); }

/* --- Stats box --- */

#stats-box {
  margin-top: 1.5rem;
  padding: 1rem 1.25rem;
  background: var(--bg-card);
  border-radius: 12px;
  color: var(--text-card);
  font-size: 0.85rem;
  line-height: 1.7;
  transition: background 0.3s;
}

#stats-box strong { color: var(--text-card-strong); }

#stats-box ul {
  list-style: disc;
  padding-left: 1.25rem;
  margin: 0.3rem 0 0;
}

/* --- Explanation --- */

#explanation {
  text-align: center;
  margin-top: 1.5rem;
  padding: 1rem;
  background: var(--bg-card);
  border-radius: 12px;
  color: var(--text-card);
  font-size: 0.85rem;
  line-height: 1.6;
  transition: background 0.3s;
}

#explanation strong { color: var(--text-card-strong); }

#data-time {
  font-size: 0.78rem;
  color: var(--text-muted);
  font-style: italic;
}

/* --- Crosslink --- */

.see-also {
  position: absolute;
  top: 0;
  left: 0;
  font-size: 0.75rem;
  color: var(--text-muted);
}

.see-also a {
  color: var(--text-muted);
  text-decoration: none;
}

.see-also a:hover { text-decoration: underline; }

/* --- Footer --- */

footer {
  text-align: center;
  margin-top: 0.5rem;
  font-size: 0.75rem;
  color: var(--footer-text);
}

footer a {
  color: var(--footer-link);
  text-decoration: none;
}

footer a:hover { color: var(--footer-link-hover); text-decoration: underline; }

/* --- Details lightbox --- */

#details-link {
  color: var(--accent);
  text-decoration: none;
  margin-left: 0.3rem;
}
#details-link:hover { color: var(--accent-hover); text-decoration: underline; }

#details-modal {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
}

#details-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.55);
}

#details-card {
  position: relative;
  max-width: 600px;
  width: calc(100% - 2rem);
  max-height: calc(100vh - 4rem);
  overflow-y: auto;
  background: var(--bg-card);
  color: var(--text);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  line-height: 1.65;
  font-size: 0.88rem;
}

#details-card h3 {
  color: var(--text-heading);
  font-size: 1.15rem;
  font-weight: 600;
  margin-bottom: 1rem;
}

#details-card h4 {
  color: var(--text-card-strong);
  font-size: 0.92rem;
  font-weight: 600;
  margin-top: 1.2rem;
  margin-bottom: 0.4rem;
}

#details-card p {
  margin-bottom: 0.7rem;
  color: var(--text-card);
}

#details-card strong { color: var(--text-card-strong); }

#details-card code {
  font-size: 0.82rem;
  background: var(--bg);
  padding: 0.1rem 0.35rem;
  border-radius: 4px;
}

#details-card a { color: var(--accent); text-decoration: none; }
#details-card a:hover { color: var(--accent-hover); text-decoration: underline; }

#details-close {
  position: absolute;
  top: 0.75rem;
  right: 0.75rem;
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 1.5rem;
  line-height: 1;
  cursor: pointer;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  transition: color 0.15s, background 0.15s;
}
#details-close:hover { color: var(--text); background: rgba(128,128,128,0.15); }

/* --- Responsive --- */

@media (max-width: 600px) {
  #app { padding: 1rem 0.75rem; }
  header h1 { font-size: 1.6rem; }
  #zip-form label { font-size: 0.75rem; }
  #loc-input { width: 160px; font-size: 0.9rem; padding: 0.5rem 0.8rem; }
  #chart-container { padding: 1rem 0.5rem 0.5rem; border-radius: 8px; }
  #location-name { font-size: 1.1rem; }
  #theme-toggle .opt { font-size: 0.7rem; padding: 0.2rem 0.4rem; }
  #details-card { padding: 1.5rem 1rem; font-size: 0.84rem; }
  #explanation { font-size: 0.8rem; padding: 0.75rem; }
  #stats-box { font-size: 0.8rem; padding: 0.75rem 1rem; }
  .see-also { position: static; margin-bottom: 0.5rem; }
}
</style>
</head>
<body>

<div id="app">
  <header>
    <h1><svg class="logo-icon" viewBox="0 0 32 36" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="lg" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#00cfd8"/><stop offset="100%" stop-color="#0088a0"/></linearGradient></defs><g stroke="url(#lg)" stroke-linecap="round" fill="none"><!-- upper arms (normal weight) --><g stroke-width="2.2"><line x1="16" y1="3" x2="16" y2="14"/><line x1="16" y1="3" x2="13" y2="6.5"/><line x1="16" y1="3" x2="19" y2="6.5"/><line x1="4.7" y1="9.5" x2="14" y2="14.9"/><line x1="4.7" y1="9.5" x2="5.8" y2="13.6"/><line x1="4.7" y1="9.5" x2="8.8" y2="9.2"/><line x1="27.3" y1="9.5" x2="18" y2="14.9"/><line x1="27.3" y1="9.5" x2="23.2" y2="9.2"/><line x1="27.3" y1="9.5" x2="26.2" y2="13.6"/><line x1="4.7" y1="22.5" x2="14" y2="17.1"/><line x1="4.7" y1="22.5" x2="8.8" y2="22.8"/><line x1="4.7" y1="22.5" x2="5.8" y2="18.4"/><line x1="27.3" y1="22.5" x2="18" y2="17.1"/><line x1="27.3" y1="22.5" x2="23.2" y2="22.8"/><line x1="27.3" y1="22.5" x2="26.2" y2="18.4"/></g><!-- downward arm (emphasized) --><g stroke-width="2.8"><line x1="16" y1="18" x2="16" y2="34"/><line x1="16" y1="34" x2="11.8" y2="29"/><line x1="16" y1="34" x2="20.2" y2="29"/><line x1="16" y1="27" x2="12.8" y2="24"/><line x1="16" y1="27" x2="19.2" y2="24"/></g></g></svg>Cryofront</h1>
    <p class="subtitle">The Pareto frontier of sustained cold.</p>
    <div class="see-also">See also: <a href="thermofront.html">[Thermofront]</a> <a href="teletherm.html">[Teletherm]</a></div>
    <div id="theme-toggle-wrap">
      <div class="slide-toggle" id="theme-toggle">
        <div class="slider"></div>
        <span class="opt" data-val="dark">Dark</span>
        <span class="opt" data-val="light">Light</span>
      </div>
    </div>
  </header>

  <form id="zip-form">
    <label for="loc-input">City/ZIP:</label>
    <div id="loc-wrap">
      <input type="text" id="loc-input" placeholder="City or US ZIP code" autocomplete="off" spellcheck="false">
      <ul id="loc-suggestions"></ul>
    </div>
    <button type="submit" id="go-btn">Go</button>
    <div class="slide-toggle" id="unit-toggle">
      <div class="slider"></div>
      <span class="opt" data-val="F">°F</span>
      <span class="opt" data-val="C">°C</span>
    </div>
    <div class="slide-toggle" id="range-toggle">
      <div class="slider"></div>
      <span class="opt" data-val="10">10 year</span>
      <span class="opt" data-val="50">50 year</span>
    </div>
    <div id="checkbox-row">
      <label id="lastk-label"><input type="checkbox" id="lastk-toggle"> Last <em>k</em> days</label>
      <label id="incl-current-label"><input type="checkbox" id="incl-current-toggle" checked> Include current</label>
      <label id="incl-today-label"><input type="checkbox" id="incl-today-toggle" checked> Include today so far</label>
    </div>
  </form>

  <div id="status-area"></div>

  <div id="chart-container" style="display:none;">
    <h2 id="location-name"></h2>
    <div id="chart-wrapper">
      <canvas id="thermochron-chart"></canvas>
    </div>
    <div id="chart-legend"></div>
    <button id="export-btn" title="Save as PNG">Save PNG</button>
  </div>

  <div id="stats-box" style="display:none;">
    <p id="stats-city"></p>
    <ul id="stats-list"></ul>
  </div>

  <div id="explanation">
    <strong>What is a cryofront?</strong> A <em>minimax curve</em> for winter cold:
    for each streak length <em>k</em>, find the coldest <em>k</em>-day window in the season
    and report its peak daily high. This is a
    <em>Pareto frontier</em> of cold&mdash;there was no longer cold streak without
    allowing a higher ceiling temperature during that season.
    Where a curve crosses <strong>32&deg;F</strong>,
    that&rsquo;s how many consecutive days the temperature never rose above freezing.
    The bold line is the current season (Oct&ndash;Sep).
    The dashed line (toggle &ldquo;Last <em>k</em> days&rdquo;) shows the
    peak high over the most recent <em>k</em> days&mdash;a snapshot of right now.
    <span id="data-time"></span>
    <a href="#" id="details-link">More details&hellip;</a>
  </div>

  <div id="details-modal" style="display:none;">
    <div id="details-backdrop"></div>
    <div id="details-card">
      <button id="details-close" aria-label="Close">&times;</button>
      <h3>How the Cryofront Works</h3>
      <p>
        Pick a number of days&mdash;say 7. Now look at every 7-day stretch during
        the winter and ask: what was the highest temperature during that stretch?
        The cryofront finds the 7-day stretch where that high was as
        <strong>low as possible</strong>. That&rsquo;s the coldest week of winter,
        measured by how warm it got at its warmest.
      </p>
      <p>
        Repeat for every streak length from 1 to 42 days and you get a curve.
        At <em>k</em>&nbsp;=&nbsp;1, the cryofront is simply the lowest single-day
        high of the season&mdash;the day whose high temperature was the coldest.
        As <em>k</em> grows, longer streaks inevitably include a warmer day, so
        the curve rises. This tradeoff is a
        <em>Pareto frontier</em>&mdash;you can&rsquo;t find a longer cold streak
        without allowing a higher peak temperature.
      </p>
      <p>
        Where a curve crosses <strong>32&deg;F</strong>, it means the daily high
        never rose above freezing for that many consecutive days.
      </p>
      <h4>Reading the chart</h4>
      <p>
        Each line is one season. The <strong>bold line</strong> is the current
        season (updated as winter progresses). The x-axis is the streak length
        in days; the y-axis is the peak daily high during that streak.
        Hover over any point to see the exact dates of the cold streak.
      </p>
      <p>
        The optional <strong>&ldquo;Last <em>k</em> days&rdquo;</strong> overlay
        (dashed line) shows the maximum daily high over the most recent
        <em>k</em> days, ending today. Today&rsquo;s value is the high
        temperature <em>so far</em> today&mdash;it may rise as the day
        progresses, which is worth keeping in mind on a warm afternoon.
        The &ldquo;last <em>k</em>&rdquo; line is always at or above the current
        season&rsquo;s cryofront, since the cryofront picks the
        <em>best</em> window while &ldquo;last <em>k</em>&rdquo; is one specific
        trailing window.
      </p>
      <h4>Daily highs only</h4>
      <p>
        All computations use <strong>daily high temperatures</strong>&mdash;one
        value per day, representing the warmest temperature recorded that day.
        The tool does not consider hourly data or intraday windows. A finer-grained
        analysis using hourly temperatures could identify colder sub-day stretches,
        but the daily-high framing gives a natural, calendar-aligned view of
        sustained cold.
      </p>
      <h4>Seasons &amp; data</h4>
      <p>
        A season runs from October&nbsp;1 through September&nbsp;30.
        The current season&rsquo;s curve updates throughout the year as new days
        are added. When two equally cold streaks exist, the most recent one is
        shown&mdash;so an ongoing cold snap always appears.
      </p>
      <p>
        Weather data (daily high temperatures) comes from the
        <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a>
        historical archive.
      </p>
      <h4>Include current season</h4>
      <p>
        The current season (Oct&ndash;Sep) is often incomplete&mdash;winter
        may not have ended yet, so its cryofront only reflects data so far.
        Uncheck this box to hide the current season and compare only
        complete historical seasons against each other. When unchecked,
        the bold &ldquo;current&rdquo; line disappears and records are
        computed across historical seasons only.
      </p>
      <h4>Include today so far</h4>
      <p>
        By default, data ends at yesterday&mdash;the most recent day with
        a final, complete daily high. Check this box to append today&rsquo;s
        <strong>observed high so far</strong>, computed from hourly
        temperatures recorded up to the most recent hour. Because the day
        is still in progress, today&rsquo;s high may rise later; the value
        updates each time you reload. This affects both the season curves
        and the &ldquo;Last <em>k</em> days&rdquo; overlay.
      </p>
    </div>
  </div>

  <footer>
    Last updated Feb 10, 2026. Cooked with Claude by <a href="https://jugander.github.io/" target="_blank" rel="noopener">Johan Ugander</a>. Weather data by <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo.com</a>
    (<a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY 4.0</a>)
  </footer>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3/dist/chartjs-plugin-annotation.min.js"></script>
<script>
// =========================================================================
// Configuration
// =========================================================================

const CONFIG = {
  GEOCODING_URL: 'https://geocoding-api.open-meteo.com/v1/search',
  ARCHIVE_URL: 'https://archive-api.open-meteo.com/v1/archive',
  TIMEZONE: 'America/New_York',
  MAX_K: 42,
  CACHE_MAX_AGE_MS: 3600 * 1000,
};

let chartInstance = null;
let lastResults = null;    // for re-rendering on theme/unit change
let lastLocationName = '';
let useCelsius = false;
let numSeasons = 10;

// Cache both 10y and 50y results per location so toggling doesn't re-fetch
let cachedResults10 = null;
let cachedResults50 = null;
let cachedLocation = null;
let showLastK = false;
let includeCurrent = true;
let includeToday = true;
let lastObservedHour = null;
let lastKData = null;  // raw Fahrenheit values for "last k days" line
let lastKDataNoToday = null;
let lastFetchTime = 0;

function toDisplay(f) { return useCelsius ? (f - 32) * 5 / 9 : f; }
function unitLabel() { return useCelsius ? '\u00b0C' : '\u00b0F'; }
function freezingTemp() { return useCelsius ? 0 : 32; }

function isDark() { return !document.documentElement.classList.contains('light'); }

function theme() {
  const dark = isDark();
  return {
    currentLine: dark ? '#ffffff' : '#1a1a2e',
    axisText: dark ? '#888' : '#777',
    axisTitle: dark ? '#999' : '#666',
    grid: dark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.08)',
    freezeLine: dark ? 'rgba(200,200,200,0.5)' : 'rgba(100,100,100,0.4)',
    freezeLabel: dark ? 'rgba(200,200,200,0.7)' : 'rgba(80,80,80,0.7)',
    dimAlpha: dark ? '50' : '40',   // hex alpha for non-highlighted on hover
    fadeAlpha: dark ? '99' : '73',   // hex alpha for historical lines at rest
  };
}

// =========================================================================
// Cache (localStorage)
// =========================================================================

function readCache(key, maxAgeMs) {
  try {
    const raw = localStorage.getItem('tc_' + key);
    if (!raw) return null;
    const entry = JSON.parse(raw);
    if (maxAgeMs != null) {
      if (Date.now() - entry.ts > maxAgeMs) return null;
    }
    return entry.d;
  } catch { return null; }
}

function writeCache(key, data) {
  try {
    localStorage.setItem('tc_' + key, JSON.stringify({ d: data, ts: Date.now() }));
  } catch { /* full or unavailable */ }
}

// =========================================================================
// Helpers
// =========================================================================

function isoDate(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

// =========================================================================
// Geocoding
// =========================================================================

function isZip(s) { return /^\d{5}$/.test(s); }

async function geocodeQuery(query) {
  const key = query.trim().toLowerCase();
  const cacheKey = `geo_${key}`;
  const cached = readCache(cacheKey);
  if (cached) return cached;

  // Strip ", State/Country" suffix — the API only matches city names
  const apiQuery = query.trim().replace(/,.*$/, '').trim();
  const resp = await fetch(`${CONFIG.GEOCODING_URL}?name=${encodeURIComponent(apiQuery)}&count=10&language=en&format=json`);
  if (!resp.ok) throw new Error(`Geocoding failed (HTTP ${resp.status})`);
  const data = await resp.json();
  const results = data.results || [];

  const zip = isZip(query) ? query : null;

  // ZIP lookup: US only
  if (zip) {
    for (const r of results) {
      if (r.country_code === 'US' && (r.postcodes || []).includes(zip)) {
        const loc = { name: `${r.name}, ${r.admin1 || ''}`, lat: r.latitude, lon: r.longitude };
        writeCache(cacheKey, loc);
        return loc;
      }
    }
    // ZIP fallback: try Zippopotam.us when Open-Meteo has no US match
    try {
      const zResp = await fetch(`https://api.zippopotam.us/us/${zip}`);
      if (zResp.ok) {
        const zData = await zResp.json();
        if (zData.places && zData.places.length > 0) {
          const p = zData.places[0];
          const loc = {
            name: `${p['place name']}, ${p.state}`,
            lat: parseFloat(p.latitude),
            lon: parseFloat(p.longitude),
          };
          writeCache(cacheKey, loc);
          return loc;
        }
      }
    } catch (_) { /* fall through to error */ }
    throw new Error(`No US location found for ZIP "${query}"`);
  }
  // City lookup: accept any country
  if (results.length > 0) {
    const r = results[0];
    const isUS = r.country_code === 'US';
    const name = isUS ? `${r.name}, ${r.admin1 || ''}` : `${r.name}, ${r.country || ''}`;
    const loc = { name, lat: r.latitude, lon: r.longitude };
    writeCache(cacheKey, loc);
    return loc;
  }
  throw new Error(`No location found for "${query}"`);
}

// Autocomplete search — returns array of {name, admin1, lat, lon}
async function geocodeSearch(query) {
  const resp = await fetch(`${CONFIG.GEOCODING_URL}?name=${encodeURIComponent(query)}&count=10&language=en&format=json`);
  if (!resp.ok) return [];
  const data = await resp.json();
  return (data.results || [])
    .slice(0, 5)
    .map(r => ({
      name: r.name,
      admin1: r.admin1 || '',
      country: r.country || '',
      countryCode: r.country_code || '',
      lat: r.latitude,
      lon: r.longitude,
    }));
}

// Selected location from autocomplete (bypass geocoding on submit)
let selectedLoc = null;

// =========================================================================
// Seasons
// =========================================================================

function makeWinterSeasons(count, ref) {
  if (!ref) {
    ref = new Date();
  }
  const currentYear = ref.getMonth() >= 9 ? ref.getFullYear() : ref.getFullYear() - 1;
  const seasons = [];
  for (let y = currentYear - count + 1; y <= currentYear; y++) {
    const start = new Date(y, 9, 1);          // Oct 1
    const nomEnd = new Date(y + 1, 8, 30);    // Sep 30
    const end = nomEnd < ref ? nomEnd : ref;
    const label = `Winter ${y}-${String((y + 1) % 100).padStart(2, '0')}`;
    seasons.push({ label, start, end, year: y });
  }
  return seasons;
}

// =========================================================================
// Weather data
// =========================================================================

async function fetchTodayObservedHigh(loc) {
  const lat = loc.lat.toFixed(4);
  const lon = loc.lon.toFixed(4);
  const cacheKey = `th_${lat}_${lon}`;
  const cached = readCache(cacheKey, 15 * 60 * 1000); // 15-min cache
  if (cached !== null && cached.hour) {
    lastObservedHour = cached.hour;
    return cached.value;
  }

  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
    `&hourly=temperature_2m&temperature_unit=fahrenheit` +
    `&timezone=${CONFIG.TIMEZONE}&past_hours=24&forecast_hours=0`;
  const resp = await fetch(url);
  if (!resp.ok) return null;
  const data = await resp.json();
  if (!data.hourly) return null;

  const todayStr = isoDate(new Date());
  const times = data.hourly.time;
  const temps = data.hourly.temperature_2m;
  let high = -Infinity;
  let latestHour = null;
  for (let i = 0; i < times.length; i++) {
    if (times[i].startsWith(todayStr) && temps[i] !== null) {
      if (temps[i] > high) high = temps[i];
      latestHour = times[i];
    }
  }
  if (high === -Infinity) return null;
  lastObservedHour = latestHour;
  writeCache(cacheKey, { value: high, hour: latestHour });
  return high;
}

async function fetchDailyHighs(loc, startDate, endDate) {
  const lat = loc.lat.toFixed(4);
  const lon = loc.lon.toFixed(4);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  // If endDate is today, fetch archive through yesterday then append
  // today's observed high from the Forecast API
  const endsToday = isoDate(endDate) === isoDate(today);
  const archiveEnd = endsToday ? yesterday : endDate;

  const s = isoDate(startDate);
  const e = isoDate(archiveEnd);

  const cacheKey = `h_${lat}_${lon}_${s}_${e}`;
  const isRecent = archiveEnd >= yesterday;
  let temps = readCache(cacheKey, isRecent ? CONFIG.CACHE_MAX_AGE_MS : undefined);

  if (!temps) {
    const url = `${CONFIG.ARCHIVE_URL}?latitude=${lat}&longitude=${lon}` +
      `&start_date=${s}&end_date=${e}` +
      `&daily=temperature_2m_max&temperature_unit=fahrenheit` +
      `&timezone=${CONFIG.TIMEZONE}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Weather API error (HTTP ${resp.status})`);
    const data = await resp.json();
    if (!data.daily) throw new Error('Unexpected API response');

    temps = [];
    const rawTemps = data.daily.temperature_2m_max;
    for (let i = 0; i < rawTemps.length; i++) {
      if (rawTemps[i] !== null) temps.push(rawTemps[i]);
    }
    if (temps.length === 0) throw new Error('No temperature data available');

    writeCache(cacheKey, temps);
  }

  if (endsToday) {
    const todayHigh = await fetchTodayObservedHigh(loc);
    if (todayHigh !== null) temps = [...temps, todayHigh];
  }

  return temps;
}

// =========================================================================
// Thermochron computation
// =========================================================================

function computeThermochron(dailyHighs) {
  const n = dailyHighs.length;
  if (n === 0) return { k: [], v: [], starts: [] };

  const maxK = Math.min(CONFIG.MAX_K, n);
  const kValues = [];
  const thermoValues = [];
  const startIndices = [];  // index of best window start for each k

  for (let k = 1; k <= maxK; k++) {
    let minOfMax = Infinity;
    let bestStart = 0;
    for (let i = 0; i <= n - k; i++) {
      let wMax = -Infinity;
      for (let j = i; j < i + k; j++) {
        if (dailyHighs[j] > wMax) wMax = dailyHighs[j];
      }
      if (wMax <= minOfMax) { minOfMax = wMax; bestStart = i; }
    }
    kValues.push(k);
    thermoValues.push(minOfMax);
    startIndices.push(bestStart);
  }

  return { k: kValues, v: thermoValues, starts: startIndices };
}

// Trailing-window max: for each k, max of the last k values in the array
function computeLastK(dailyHighs) {
  const n = dailyHighs.length;
  const maxK = Math.min(CONFIG.MAX_K, n);
  const values = [];
  for (let k = 1; k <= maxK; k++) {
    let mx = -Infinity;
    for (let j = n - k; j < n; j++) {
      if (dailyHighs[j] > mx) mx = dailyHighs[j];
    }
    values.push(mx);
  }
  return values;
}

// =========================================================================
// UI helpers
// =========================================================================

const statusEl = document.getElementById('status-area');
const chartContainer = document.getElementById('chart-container');
function showStatus(msg) {
  statusEl.className = 'loading';
  statusEl.innerHTML = '<span class="spinner"></span>' + msg;
}

function showError(msg) {
  statusEl.className = 'error';
  statusEl.textContent = msg;
}

function clearStatus() {
  statusEl.className = '';
  statusEl.innerHTML = '';
}

function showChart() { chartContainer.style.display = ''; }
function hideChart() { chartContainer.style.display = 'none'; }

// =========================================================================
// Chart rendering
// =========================================================================

const COLORS = [
  '#5b9bd5', '#ed7d31', '#70ad47', '#e84d60', '#9e7cc1',
  '#c17d56', '#e89ac7', '#a0a0a0', '#c4bd36', '#4fc1c9',
];

function hslToHex(h, s, l) {
  s /= 100; l /= 100;
  const a = s * Math.min(l, 1 - l);
  const f = n => {
    const k = (n + h / 30) % 12;
    const c = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * c).toString(16).padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`;
}

function gradient50Hex(index, total, dark) {
  const t = total <= 1 ? 0 : index / (total - 1);
  const hue = 220 * (1 - t);
  const sat = 65 + 15 * t;
  const lit = dark ? (55 + 10 * t) : (40 + 10 * t);
  return hslToHex(hue, sat, lit);
}

// ---- Nearest-line highlight plugin ----

let highlightIndex = -1; // -1 = no hover, use default (current season bold)
let hoverDataIdx = -1;   // x-axis data index under cursor
let hoverMouseX = 0;
let hoverMouseY = 0;
const pinnedSets = new Set(); // dataset indices pinned via legend clicks

const highlightPlugin = {
  id: 'highlightNearest',

  afterEvent(chart, args) {
    const evt = args.event;
    const hasPins = pinnedSets.size > 0;

    if (evt.type === 'mouseout') {
      if (highlightIndex !== -1 || hoverDataIdx !== -1) {
        highlightIndex = -1;
        hoverDataIdx = -1;
        if (!hasPins) applyHighlight(chart, -1);
        args.changed = true;
      }
      return;
    }
    if (evt.type !== 'mousemove') return;

    const mouseY = evt.y;
    const mouseX = evt.x;
    hoverMouseX = mouseX;
    hoverMouseY = mouseY;
    const area = chart.chartArea;
    if (!area || mouseX < area.left || mouseX > area.right ||
        mouseY < area.top || mouseY > area.bottom) {
      if (highlightIndex !== -1 || hoverDataIdx !== -1) {
        highlightIndex = -1;
        hoverDataIdx = -1;
        if (!hasPins) applyHighlight(chart, -1);
        args.changed = true;
      }
      return;
    }

    // Find nearest data index by pixel x-distance
    const firstMeta = chart.getDatasetMeta(0);
    let dataIdx = 0;
    let bestXDist = Infinity;
    for (let i = 0; i < firstMeta.data.length; i++) {
      const dx = Math.abs(firstMeta.data[i].x - mouseX);
      if (dx < bestXDist) {
        bestXDist = dx;
        dataIdx = i;
      }
    }

    // Find nearest dataset by y-distance at this x index
    // When pins are active, only consider pinned datasets
    let nearest = -1;
    let nearestDist = Infinity;
    const datasets = chart.data.datasets;
    for (let i = 0; i < datasets.length; i++) {
      if (hasPins && !pinnedSets.has(i)) continue;
      const val = datasets[i].data[dataIdx];
      if (val == null) continue;
      const yPixel = chart.scales.y.getPixelForValue(val);
      const dist = Math.abs(yPixel - mouseY);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = i;
      }
    }

    const changed = nearest !== highlightIndex || dataIdx !== hoverDataIdx;
    hoverDataIdx = dataIdx;
    if (changed) {
      highlightIndex = nearest;
      if (!hasPins) applyHighlight(chart, nearest);
      args.changed = true;
    }
  },

  afterDraw(chart) {
    const area = chart.chartArea;
    const ctx = chart.ctx;
    const dark = isDark();
    const fontMain = '11px system-ui, sans-serif';
    const fontSub = '10px system-ui, sans-serif';

    // Info box for hovered (or nearest pinned) dataset
    const idx = highlightIndex;
    if (idx === -1 || hoverDataIdx === -1) return;
    const meta = chart.getDatasetMeta(idx);
    if (!meta.visible) return;
    const ds = chart.data.datasets[idx];

    const val = ds.data[hoverDataIdx];
    if (val == null) return;
    const pt = meta.data[hoverDataIdx];
    if (!pt) return;

    const k = hoverDataIdx + 1;
    const displayVal = val.toFixed(1);
    let line1, line2 = '';

    if (ds._isLastK) {
      line1 = `Last ${k}d  ${displayVal}${unitLabel()}`;
      const fmt = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      const endDay = new Date();
      const startDay = new Date();
      startDay.setDate(startDay.getDate() - k + 1);
      line2 = `${fmt(startDay)}\u2013${fmt(endDay)}`;
    } else {
      const seasonTag = ds.label.replace('Winter ', '');
      line1 = `${seasonTag}  ${k}d  ${displayVal}${unitLabel()}`;

      // Date range of the best k-day window
      if (ds._starts && ds._seasonStart && ds._starts[hoverDataIdx] != null) {
        const s0 = new Date(ds._seasonStart);
        const startDay = new Date(s0.getFullYear(), s0.getMonth(), s0.getDate() + ds._starts[hoverDataIdx]);
        const endDay = new Date(startDay.getFullYear(), startDay.getMonth(), startDay.getDate() + k - 1);
        const fmt = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        line2 = `${fmt(startDay)}\u2013${fmt(endDay)}`;
      }
      // Flag all-time low on the current season
      const isLow = ds._allTimeLow && ds._allTimeLow[hoverDataIdx];
      if (isLow) {
        const recLabel = `\u2605 ${numSeasons}y record`;
        line2 = line2 ? `${line2}  ${recLabel}` : recLabel;
      }
    }

    ctx.save();
    ctx.font = fontMain;
    const tw1 = ctx.measureText(line1).width;
    ctx.font = fontSub;
    const tw2 = line2 ? ctx.measureText(line2).width : 0;
    const pad = 5;
    const boxW = Math.max(tw1, tw2) + pad * 2;
    const lineH = 14;
    const boxH = line2 ? lineH * 2 + 4 : lineH + 6;
    // Position above the point, shift left if near right edge
    let bx = pt.x - boxW / 2;
    let by = pt.y - boxH - 8;
    if (bx < area.left) bx = area.left;
    if (bx + boxW > area.right) bx = area.right - boxW;
    if (by < area.top) by = pt.y + 8; // flip below if at top

    ctx.fillStyle = dark ? 'rgba(22,33,62,0.92)' : 'rgba(255,255,255,0.92)';
    ctx.strokeStyle = dark ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(bx, by, boxW, boxH, 4);
    ctx.fill();
    ctx.stroke();

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const cx = bx + boxW / 2;
    if (line2) {
      ctx.font = fontMain;
      ctx.fillStyle = dark ? '#eee' : '#333';
      ctx.fillText(line1, cx, by + lineH / 2 + 2);
      ctx.font = fontSub;
      ctx.fillStyle = dark ? '#aaa' : '#777';
      ctx.fillText(line2, cx, by + lineH + lineH / 2 + 2);
    } else {
      ctx.font = fontMain;
      ctx.fillStyle = dark ? '#eee' : '#333';
      ctx.fillText(line1, cx, by + boxH / 2);
    }
    ctx.restore();

    // Small dot on the data point
    ctx.save();
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = ds._baseColor || '#ffffff';
    ctx.fill();
    ctx.restore();
  },
};

function applyHighlight(chart, hoveredIdx) {
  const datasets = chart.data.datasets;
  const t = theme();
  const is50 = numSeasons === 50;
  const dark = isDark();
  const restAlpha = is50 ? (dark ? '45' : '30') : t.fadeAlpha;
  const restWidth = is50 ? 0.8 : 1.3;
  const hasPins = pinnedSets.size > 0;

  for (let i = 0; i < datasets.length; i++) {
    const ds = datasets[i];
    const isCurrent = !!ds._isCurrent;
    const isLastK = !!ds._isLastK;
    const isHovered = i === hoveredIdx;
    const isPinned = pinnedSets.has(i);
    if (isCurrent) ds._baseColor = t.currentLine;

    if (hasPins) {
      // Pinned mode: pinned datasets highlighted, everything else dimmed
      if (isPinned) {
        ds.borderColor = ds._baseColor;
        ds.borderWidth = 3;
      } else {
        ds.borderColor = ds._baseColor + (is50 ? (dark ? '28' : '18') : t.dimAlpha);
        ds.borderWidth = isLastK ? 1.5 : (is50 ? 0.6 : 1.1);
      }
    } else if (hoveredIdx === -1) {
      // No hover — default styling
      if (isCurrent) {
        ds.borderColor = t.currentLine;
        ds.borderWidth = 3.5;
      } else if (isLastK) {
        ds.borderColor = ds._baseColor;
        ds.borderWidth = 2.5;
      } else {
        ds.borderColor = ds._baseColor + restAlpha;
        ds.borderWidth = restWidth;
      }
    } else {
      if (isHovered) {
        ds.borderColor = ds._baseColor;
        ds.borderWidth = 3;
      } else {
        ds.borderColor = ds._baseColor + (is50 ? (dark ? '28' : '18') : t.dimAlpha);
        ds.borderWidth = isLastK ? 1.5 : (is50 ? 0.6 : 1.1);
      }
    }
  }
  chart.update('none');
}

// ---- Chart rendering ----

function renderChart(allResults, locationName) {
  const ctx = document.getElementById('thermochron-chart');
  const t = theme();

  if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
  highlightIndex = -1;

  // Store for re-render on theme change
  lastResults = allResults;
  lastLocationName = locationName;

  const labels = Array.from({ length: CONFIG.MAX_K }, (_, i) => i + 1);

  const fz = freezingTemp();

  const is50 = numSeasons === 50;
  const dark = isDark();

  // Filter out current season if not included
  let displayResults = includeCurrent
    ? allResults
    : allResults.filter((_, i) => i < allResults.length - 1);
  if (displayResults.length === 0) return;

  // Swap current season to without-today version if needed
  if (!includeToday && displayResults.length > 0) {
    const last = displayResults[displayResults.length - 1];
    if (last.vNoToday) {
      displayResults = displayResults.map((r, i) =>
        i === displayResults.length - 1
          ? { ...r, k: r.kNoToday, v: r.vNoToday, starts: r.startsNoToday }
          : r
      );
    }
  }

  const histCount = displayResults.length - 1;

  // Compute per-season records: for each season & k, is it the min across all displayed?
  const allRecords = displayResults.map((r, idx) => {
    const rec = new Array(CONFIG.MAX_K).fill(false);
    for (let ki = 0; ki < CONFIG.MAX_K; ki++) {
      const val = r.v[ki];
      if (val == null) continue;
      let isMin = true;
      for (let s = 0; s < displayResults.length; s++) {
        if (s === idx) continue;
        const other = displayResults[s].v[ki];
        if (other != null && other <= val) { isMin = false; break; }
      }
      rec[ki] = isMin;
    }
    return rec;
  });

  const datasets = displayResults.map((r, idx) => {
    const isCurrent = idx === displayResults.length - 1;
    const baseColor = isCurrent ? t.currentLine
      : is50 ? gradient50Hex(idx, histCount, dark) : COLORS[idx % COLORS.length];
    const displayData = r.v.slice(0, CONFIG.MAX_K).map(toDisplay);
    const ds = {
      label: r.season.label,
      data: displayData,
      _rawData: r.v.slice(0, CONFIG.MAX_K),
      _starts: r.starts ? r.starts.slice(0, CONFIG.MAX_K) : null,
      _seasonStart: r.season.start,
      _baseColor: baseColor,
      _allTimeLow: allRecords[idx],
      borderColor: isCurrent ? t.currentLine
        : is50 ? baseColor + (dark ? '45' : '30') : baseColor + t.fadeAlpha,
      borderWidth: isCurrent ? 3.5 : (is50 ? 0.8 : 1.3),
      backgroundColor: 'transparent',
      pointRadius: 0,
      pointHitRadius: 8,
      tension: 0,
      order: isCurrent ? 0 : 1,
    };
    if (isCurrent) {
      ds._isCurrent = true;
    }
    return ds;
  });

  // "Last k days" overlay dataset
  const activeLastK = includeToday ? lastKData : lastKDataNoToday;
  if (showLastK && activeLastK) {
    const lkColor = dark ? '#ff9f43' : '#d35400';
    const displayLK = activeLastK.slice(0, CONFIG.MAX_K).map(toDisplay);
    datasets.push({
      label: 'Last k days',
      data: displayLK,
      _rawData: activeLastK.slice(0, CONFIG.MAX_K),
      _baseColor: lkColor,
      _isLastK: true,
      borderColor: lkColor,
      borderWidth: 2.5,
      borderDash: [6, 3],
      backgroundColor: 'transparent',
      pointRadius: 0,
      pointHitRadius: 8,
      tension: 0,
      order: 0,
    });
  }

  document.getElementById('location-name').textContent = `Cryofront \u2014 ${locationName}`;

  chartInstance = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    plugins: [highlightPlugin],
    options: {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: window.innerWidth < 600 ? 4 / 3 : 5 / 3,
      interaction: { mode: 'nearest', axis: 'x', intersect: false },
      scales: {
        x: {
          title: { display: true, text: 'k (streak length in days)', color: t.axisTitle, font: { size: 12 } },
          ticks: {
            color: t.axisText,
            stepSize: 7,
            callback: (val) => val + 1,
          },
          afterBuildTicks(scale) {
            scale.ticks = [];
            for (let v = 7; v <= CONFIG.MAX_K; v += 7) {
              scale.ticks.push({ value: v - 1 });  // 0-based index into labels
            }
          },
          grid: { color: t.grid },
          min: 1,
          max: CONFIG.MAX_K,
        },
        y: {
          title: { display: true, text: `Temperature (${unitLabel()})`, color: t.axisTitle, font: { size: 12 } },
          ticks: { color: t.axisText },
          grid: { color: t.grid },
        },
      },
      plugins: {
        legend: { display: false },
        annotation: {
          annotations: {
            freezing: {
              type: 'line',
              yMin: fz, yMax: fz,
              borderColor: t.freezeLine,
              borderWidth: 1,
              borderDash: [6, 4],
              label: {
                display: true,
                content: `${fz}${unitLabel()}`,
                position: 'start',
                color: t.freezeLabel,
                font: { size: 11 },
                backgroundColor: 'transparent',
              },
            },
          },
        },
        tooltip: {
          enabled: false,
        },
      },
    },
  });

  // Clear any prior pins
  pinnedSets.clear();

  // Populate legend with click-to-pin
  const legendEl = document.getElementById('chart-legend');
  legendEl.innerHTML = '';

  const pinClickHandler = (dsIndex, el) => (e) => {
    e.stopPropagation();
    if (pinnedSets.has(dsIndex)) {
      pinnedSets.delete(dsIndex);
      el.classList.remove('pinned');
    } else {
      pinnedSets.add(dsIndex);
      el.classList.add('pinned');
    }
    // Toggle has-pins class on legend container
    legendEl.classList.toggle('has-pins', pinnedSets.size > 0);
    highlightIndex = -1;
    hoverDataIdx = -1;
    applyHighlight(chartInstance, -1);
  };

  if (is50) {
    // 50y: compact labeled cells
    legendEl.className = 'grid-mode';
    datasets.forEach((ds, dsIndex) => {
      if (ds._isLastK) return;
      const cell = document.createElement('span');
      cell.className = 'leg-cell' + (ds._isCurrent ? ' current' : '');
      // Short label: "75–76" from "Winter 1975-76"
      const tag = ds.label.replace('Winter ', '').replace(/\d{2}(\d{2})-(\d{2})/, '$1\u2013$2');
      cell.innerHTML = `<span class="leg-dot" style="background:${ds._baseColor}"></span>${tag}`;
      cell.title = ds.label;
      cell.addEventListener('click', pinClickHandler(dsIndex, cell));
      // Hover preview: highlight line on chart without pinning
      cell.addEventListener('mouseenter', () => {
        if (pinnedSets.size === 0) {
          highlightIndex = dsIndex;
          applyHighlight(chartInstance, dsIndex);
        }
      });
      cell.addEventListener('mouseleave', () => {
        if (pinnedSets.size === 0) {
          highlightIndex = -1;
          applyHighlight(chartInstance, -1);
        }
      });
      legendEl.appendChild(cell);
    });
  } else {
    // 10y: named color swatches
    legendEl.className = '';
    datasets.forEach((ds, dsIndex) => {
      if (ds._isLastK) return;
      const span = document.createElement('span');
      span.className = 'leg-item' + (ds._isCurrent ? ' current' : '');
      const tag = ds.label.replace('Winter ', '');
      span.innerHTML = `<span class="leg-swatch" style="background:${ds._baseColor}"></span>${tag}`;
      span.addEventListener('click', pinClickHandler(dsIndex, span));
      legendEl.appendChild(span);
    });
  }

  // Click on chart canvas clears all pins
  const canvas = document.getElementById('thermochron-chart');
  canvas.onclick = (e) => {
    if (pinnedSets.size > 0) {
      pinnedSets.clear();
      legendEl.querySelectorAll('.pinned').forEach(el => el.classList.remove('pinned'));
      legendEl.classList.remove('has-pins');
      highlightIndex = -1;
      hoverDataIdx = -1;
      applyHighlight(chartInstance, -1);
    }
  };
}

// =========================================================================
// Freezing-streak statistics
// =========================================================================

function updateStats(allResults, locationName) {
  const statsBox = document.getElementById('stats-box');
  const statsCity = document.getElementById('stats-city');
  const statsList = document.getElementById('stats-list');
  const fmtShort = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  const fmtWithYear = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

  // Build view of results with correct today/no-today version for current season
  const activeLastK = includeToday ? lastKData : lastKDataNoToday;
  let viewResults = allResults;
  if (!includeToday && allResults.length > 0) {
    const last = allResults[allResults.length - 1];
    if (last.vNoToday) {
      viewResults = allResults.map((r, i) =>
        i === allResults.length - 1
          ? { ...r, k: r.kNoToday, v: r.vNoToday, starts: r.startsNoToday }
          : r
      );
    }
  }

  // 1. Current streak below freezing (from lastKData)
  let currentStreak = 0;
  if (activeLastK) {
    for (let k = 1; k <= activeLastK.length; k++) {
      if (activeLastK[k - 1] <= 32) currentStreak = k;
      else break;
    }
  }

  // Helper: find longest freezing streak for a season result
  function longestFreezingStreak(r) {
    let best = 0;
    for (let k = 1; k <= r.v.length; k++) {
      if (r.v[k - 1] <= 32) best = k;
      else break;
    }
    return best;
  }

  // Helper: compute date range for a streak
  function streakDates(r, k) {
    const s0 = new Date(r.season.start);
    const startDay = new Date(s0.getFullYear(), s0.getMonth(), s0.getDate() + r.starts[k - 1]);
    const endDay = new Date(startDay.getFullYear(), startDay.getMonth(), startDay.getDate() + k - 1);
    return { startDay, endDay };
  }

  // 2. Longest streak this season
  const current = viewResults[viewResults.length - 1];
  const thisSeasonK = !includeCurrent ? 0 : longestFreezingStreak(current);

  // 3. Longest streak ever (across all seasons)
  const statsResults = !includeCurrent
    ? viewResults.filter((_, i) => i < viewResults.length - 1)
    : viewResults;
  let allTimeK = 0;
  let allTimeResult = null;
  for (const r of statsResults) {
    const k = longestFreezingStreak(r);
    if (k > allTimeK) { allTimeK = k; allTimeResult = r; }
  }

  // Build bullets
  const bullets = [];

  // Bullet 1: current streak
  const dayWord = currentStreak === 1 ? 'day' : 'days';
  bullets.push(`It has been below freezing for: <strong>${currentStreak} ${dayWord}</strong>`);

  // Bullet 2: longest this season
  const seasonStart = fmtWithYear(new Date(current.season.start));
  if (!includeCurrent) {
    bullets.push(`Longest stretch below freezing this season (${seasonStart}\u2009\u2013\u2009present): <strong>N/A</strong> (excluded)`);
  } else if (thisSeasonK > 0) {
    const { startDay, endDay } = streakDates(current, thisSeasonK);
    const dayWord2 = thisSeasonK === 1 ? 'day' : 'days';
    bullets.push(`Longest stretch below freezing this season (${seasonStart}\u2009\u2013\u2009present): <strong>${fmtShort(startDay)}\u2009\u2013\u2009${fmtShort(endDay)}</strong> (<strong>${thisSeasonK} ${dayWord2}</strong>)`);
  } else {
    bullets.push(`Longest stretch below freezing this season (${seasonStart}\u2009\u2013\u2009present): <strong>N/A</strong>`);
  }

  // Bullet 3: longest since earliest season
  const sinceYear = allResults[0].season.year;
  if (allTimeK > 0 && allTimeResult) {
    const { startDay, endDay } = streakDates(allTimeResult, allTimeK);
    const dayWord3 = allTimeK === 1 ? 'day' : 'days';
    bullets.push(`Longest stretch (since ${sinceYear}) below freezing: <strong>${fmtWithYear(startDay)}\u2009\u2013\u2009${fmtWithYear(endDay)}</strong> (<strong>${allTimeK} ${dayWord3}</strong>)`);
  } else {
    bullets.push(`Longest stretch (since ${sinceYear}) below freezing: <strong>N/A</strong>`);
  }

  let throughStr;
  if (includeToday && lastObservedHour) {
    const hourDate = new Date(lastObservedHour);
    const dateStr = hourDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    const timeStr = hourDate.toLocaleTimeString('en-US', { hour: 'numeric', timeZoneName: 'short' });
    throughStr = `${dateStr}, ${timeStr}`;
  } else {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const dateStr = yesterday.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    throughStr = `${dateStr} (yesterday)`;
  }
  statsCity.innerHTML = `For <strong>${locationName}</strong> through ${throughStr}:`;
  statsList.innerHTML = bullets.map(b => `<li>${b}</li>`).join('');
  statsBox.style.display = '';

  // Update data-time display to match current includeToday state
  const dataEnd = new Date();
  if (!includeToday) dataEnd.setDate(dataEnd.getDate() - 1);
  const dtDateStr = dataEnd.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
  document.getElementById('data-time').textContent = includeToday
    ? `Data through ${dtDateStr} (today\u2019s high so far).`
    : `Data through ${dtDateStr}.`;
}

// =========================================================================
// Main
// =========================================================================

async function fetchSeasonResults(location, count) {
  const seasons = makeWinterSeasons(count);
  let done = 0;

  const promises = seasons.map(async (season, idx) => {
    const temps = await fetchDailyHighs(location, season.start, season.end);
    done++;
    showStatus(`${location.name} \u2014 fetching weather data\u2026 (${done}/${seasons.length})`);
    const tc = computeThermochron(temps);
    const result = { season, k: tc.k, v: tc.v, starts: tc.starts };
    // For current season (last one), also compute without-today version
    if (idx === count - 1 && temps.length > 1) {
      const tcY = computeThermochron(temps.slice(0, -1));
      result.kNoToday = tcY.k;
      result.vNoToday = tcY.v;
      result.startsNoToday = tcY.starts;
    }
    return result;
  });

  const settled = await Promise.allSettled(promises);
  const results = settled.filter(s => s.status === 'fulfilled').map(s => s.value);
  if (results.length === 0) throw new Error('Could not retrieve weather data for any season.');
  return results;
}

document.getElementById('zip-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  closeSuggestions();
  const query = document.getElementById('loc-input').value.trim();

  if (!query) {
    showError('Enter a city or US ZIP code.');
    return;
  }

  const goBtn = document.getElementById('go-btn');
  goBtn.disabled = true;
  hideChart();
  showStatus('Looking up location\u2026');

  try {
    let location;
    if (selectedLoc) {
      location = selectedLoc;
      selectedLoc = null;
    } else {
      location = await geocodeQuery(query);
    }
    showStatus(`${location.name} \u2014 fetching weather data\u2026`);

    const results = await fetchSeasonResults(location, numSeasons);

    // Fetch last-k-days data (last 42 days, always through today)
    const lkEnd = new Date();
    const lkStart = new Date(lkEnd);
    lkStart.setDate(lkStart.getDate() - (CONFIG.MAX_K - 1));
    const lkTemps = await fetchDailyHighs(location, lkStart, lkEnd);
    lastKData = computeLastK(lkTemps);
    lastKDataNoToday = computeLastK(lkTemps.slice(0, -1));

    // Cache results
    cachedLocation = location;
    lastFetchTime = Date.now();
    if (numSeasons === 10) cachedResults10 = results;
    else cachedResults50 = results;

    clearStatus();
    showChart();
    renderChart(results, location.name);
    updateStats(results, location.name);

  } catch (err) {
    showError(err.message);
  } finally {
    goBtn.disabled = false;
  }
});

// Pre-fill with default ZIP
document.getElementById('loc-input').value = '06515';

// Auto-load from URL query parameter (?zip=...)
const urlZip = new URLSearchParams(window.location.search).get('zip');
if (urlZip) {
  document.getElementById('loc-input').value = urlZip;
  document.getElementById('zip-form').requestSubmit();
}

// =========================================================================
// Autocomplete
// =========================================================================

const locInput = document.getElementById('loc-input');
const sugList = document.getElementById('loc-suggestions');
let acTimer = null;
let acIdx = -1; // keyboard nav index

function closeSuggestions() {
  sugList.style.display = 'none';
  sugList.innerHTML = '';
  acIdx = -1;
}

function showSuggestions(items) {
  if (items.length === 0) { closeSuggestions(); return; }
  sugList.innerHTML = '';
  acIdx = -1;
  items.forEach((item, i) => {
    const li = document.createElement('li');
    const isUS = item.countryCode === 'US';
    const sub = isUS ? item.admin1 : (item.admin1 ? `${item.admin1}, ${item.country}` : item.country);
    const displayName = isUS ? `${item.name}, ${item.admin1}` : `${item.name}, ${item.country}`;
    li.innerHTML = `${item.name}<span class="loc-sub">${sub}</span>`;
    li.addEventListener('mousedown', (e) => {
      e.preventDefault(); // don't blur input
      selectedLoc = { name: displayName, lat: item.lat, lon: item.lon };
      locInput.value = displayName;
      closeSuggestions();
      document.getElementById('zip-form').requestSubmit();
    });
    sugList.appendChild(li);
  });
  sugList.style.display = 'block';
}

locInput.addEventListener('input', () => {
  selectedLoc = null;
  clearTimeout(acTimer);
  const q = locInput.value.trim();
  // Only autocomplete for non-ZIP text >= 2 chars
  if (isZip(q) || q.length < 2) { closeSuggestions(); return; }
  acTimer = setTimeout(async () => {
    const results = await geocodeSearch(q);
    // Only show if input hasn't changed
    if (locInput.value.trim() === q) showSuggestions(results);
  }, 250);
});

locInput.addEventListener('keydown', (e) => {
  const items = sugList.querySelectorAll('li');
  if (!items.length) return;
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    acIdx = Math.min(acIdx + 1, items.length - 1);
    items.forEach((li, i) => li.classList.toggle('active', i === acIdx));
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    acIdx = Math.max(acIdx - 1, 0);
    items.forEach((li, i) => li.classList.toggle('active', i === acIdx));
  } else if (e.key === 'Enter' && acIdx >= 0) {
    e.preventDefault();
    items[acIdx].dispatchEvent(new MouseEvent('mousedown'));
  } else if (e.key === 'Escape') {
    closeSuggestions();
  }
});

locInput.addEventListener('blur', () => {
  // Small delay to allow mousedown on suggestion to fire first
  setTimeout(closeSuggestions, 150);
});

// =========================================================================
// Slide toggle helper
// =========================================================================

function updateSlider(toggle) {
  const opts = toggle.querySelectorAll('.opt');
  const slider = toggle.querySelector('.slider');
  const activeOpt = toggle.querySelector('.opt.active');
  if (!activeOpt) return;
  slider.style.left = activeOpt.offsetLeft + 'px';
  slider.style.width = activeOpt.offsetWidth + 'px';
}

// =========================================================================
// Theme toggle
// =========================================================================

const themeToggle = document.getElementById('theme-toggle');

function applyThemeState() {
  const val = isDark() ? 'dark' : 'light';
  themeToggle.querySelectorAll('.opt').forEach(o => {
    o.classList.toggle('active', o.dataset.val === val);
  });
  updateSlider(themeToggle);
}

// Default to light; restore saved preference if dark
if (localStorage.getItem('tc_theme') === 'dark') {
  document.documentElement.classList.remove('light');
} else {
  document.documentElement.classList.add('light');
}
applyThemeState();

themeToggle.addEventListener('click', () => {
  document.documentElement.classList.toggle('light');
  const mode = isDark() ? 'dark' : 'light';
  localStorage.setItem('tc_theme', mode);
  applyThemeState();
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
  }
});

// =========================================================================
// Unit toggle (°F / °C)
// =========================================================================

const unitToggle = document.getElementById('unit-toggle');

function applyUnitState() {
  const val = useCelsius ? 'C' : 'F';
  unitToggle.querySelectorAll('.opt').forEach(o => {
    o.classList.toggle('active', o.dataset.val === val);
  });
  updateSlider(unitToggle);
}

// Restore saved preference
if (localStorage.getItem('tc_unit') === 'C') {
  useCelsius = true;
}
applyUnitState();

unitToggle.addEventListener('click', () => {
  useCelsius = !useCelsius;
  localStorage.setItem('tc_unit', useCelsius ? 'C' : 'F');
  applyUnitState();
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
  }
});

// ── Range toggle (10y / 50y) ──────────────────────────────────────────
const rangeToggle = document.getElementById('range-toggle');

function applyRangeState() {
  const val = String(numSeasons);
  rangeToggle.querySelectorAll('.opt').forEach(o => {
    o.classList.toggle('active', o.dataset.val === val);
  });
  updateSlider(rangeToggle);
}

// Restore saved preference
if (localStorage.getItem('tc_range') === '50') {
  numSeasons = 50;
}
applyRangeState();

rangeToggle.addEventListener('click', async () => {
  numSeasons = numSeasons === 10 ? 50 : 10;
  localStorage.setItem('tc_range', String(numSeasons));
  applyRangeState();

  // No location loaded yet — nothing to re-render
  if (!cachedLocation) return;

  // Check cache first
  const cached = numSeasons === 10 ? cachedResults10 : cachedResults50;
  if (cached) {
    lastResults = cached;
    lastLocationName = cachedLocation.name;
    renderChart(cached, cachedLocation.name);
    updateStats(cached, cachedLocation.name);
    return;
  }

  // Need to fetch data for this range
  const goBtn = document.getElementById('go-btn');
  goBtn.disabled = true;
  hideChart();
  showStatus(`${cachedLocation.name} \u2014 fetching weather data\u2026`);

  try {
    const results = await fetchSeasonResults(cachedLocation, numSeasons);
    if (numSeasons === 10) cachedResults10 = results;
    else cachedResults50 = results;
    lastResults = results;
    lastLocationName = cachedLocation.name;
    clearStatus();
    showChart();
    renderChart(results, cachedLocation.name);
    updateStats(results, cachedLocation.name);
  } catch (err) {
    showError(err.message);
  } finally {
    goBtn.disabled = false;
  }
});

// ── "Last k days" checkbox ────────────────────────────────────────────
document.getElementById('lastk-toggle').addEventListener('change', (e) => {
  showLastK = e.target.checked;
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
  }
});

// ── "Include current season" checkbox ──────────────────────────────────
// Set dynamic label showing current season (e.g. "Include 25-26")
{
  const now = new Date();
  const cy = now.getMonth() >= 9 ? now.getFullYear() : now.getFullYear() - 1;
  const tag = `${String(cy % 100).padStart(2, '0')}-${String((cy + 1) % 100).padStart(2, '0')}`;
  const lbl = document.getElementById('incl-current-label');
  lbl.childNodes[lbl.childNodes.length - 1].textContent = ` Include ${tag}`;
}
// Default is checked (true) for cryofront; restore saved preference
if (localStorage.getItem('tc_incl') === 'false') {
  includeCurrent = false;
  document.getElementById('incl-current-toggle').checked = false;
}

document.getElementById('incl-current-toggle').addEventListener('change', (e) => {
  includeCurrent = e.target.checked;
  localStorage.setItem('tc_incl', includeCurrent ? 'true' : 'false');
  const todayToggle = document.getElementById('incl-today-toggle');
  if (!includeCurrent) {
    includeToday = false;
    todayToggle.checked = false;
    todayToggle.disabled = true;
    localStorage.setItem('tc_today', 'false');
  } else {
    todayToggle.disabled = false;
  }
  // Re-fetch only if data is stale (>1 hour old)
  if (lastResults && (Date.now() - lastFetchTime < 3600000)) {
    renderChart(lastResults, lastLocationName);
    updateStats(lastResults, lastLocationName);
  } else if (cachedLocation) {
    cachedResults10 = null;
    cachedResults50 = null;
    document.getElementById('zip-form').requestSubmit();
  }
});

// ── "Include today" checkbox ──────────────────────────────────────────
if (localStorage.getItem('tc_today') === 'false') {
  includeToday = false;
  document.getElementById('incl-today-toggle').checked = false;
}
if (!includeCurrent) {
  includeToday = false;
  document.getElementById('incl-today-toggle').checked = false;
  document.getElementById('incl-today-toggle').disabled = true;
}

document.getElementById('incl-today-toggle').addEventListener('change', (e) => {
  includeToday = e.target.checked;
  localStorage.setItem('tc_today', includeToday ? 'true' : 'false');
  // Re-fetch only if data is stale (>1 hour old)
  if (lastResults && (Date.now() - lastFetchTime < 3600000)) {
    renderChart(lastResults, lastLocationName);
    updateStats(lastResults, lastLocationName);
  } else if (cachedLocation) {
    cachedResults10 = null;
    cachedResults50 = null;
    document.getElementById('zip-form').requestSubmit();
  }
});

// ── PNG export ────────────────────────────────────────────────────────
document.getElementById('export-btn').addEventListener('click', () => {
  if (!chartInstance) return;

  const src = chartInstance.canvas;
  const dpr = window.devicePixelRatio || 1;
  const srcW = src.width;
  const srcH = src.height;
  const dark = isDark();
  const is10 = numSeasons === 10;

  const titleH = Math.round(36 * dpr);
  const need50yBar = !is10 && pinnedSets.size === 0;
  const captionH = Math.round((need50yBar ? 30 : 22) * dpr);
  const footerH = Math.round(28 * dpr);
  const padX = Math.round(12 * dpr);
  const totalW = srcW + padX * 2;
  const totalH = srcH + titleH + captionH + footerH;

  const c = document.createElement('canvas');
  c.width = totalW;
  c.height = totalH;
  const ctx = c.getContext('2d');

  // Background
  ctx.fillStyle = dark ? '#16213e' : '#ffffff';
  ctx.fillRect(0, 0, totalW, totalH);

  // Title
  const titleSize = Math.round(15 * dpr);
  ctx.font = `400 ${titleSize}px system-ui, -apple-system, sans-serif`;
  ctx.fillStyle = dark ? '#e8e8e8' : '#222';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`Cryofront \u2014 ${lastLocationName}`, totalW / 2, titleH / 2);

  // Chart
  ctx.drawImage(src, padX, titleH);

  // Caption area
  const ds = chartInstance.data.datasets;
  const capFontSize = Math.round(8.5 * dpr);
  const capY = titleH + srcH + captionH / 2;

  const hasPins = pinnedSets.size > 0;
  const swatchW = Math.round(14 * dpr);
  const swatchH = Math.round(3 * dpr);
  const gap = Math.round(6 * dpr);
  const itemGap = Math.round(12 * dpr);

  // Helper: draw a row of swatch+label items centered at capY
  function drawSwatchRow(items) {
    ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;
    let totalLegW = 0;
    items.forEach(item => { totalLegW += swatchW + gap + item.tw; });
    totalLegW += itemGap * Math.max(items.length - 1, 0);

    let x = (totalW - totalLegW) / 2;
    items.forEach((item) => {
      ctx.globalAlpha = item.dimmed ? 0.35 : 1.0;
      if (item.isDashed) {
        ctx.strokeStyle = item.color;
        ctx.lineWidth = Math.round(2 * dpr);
        ctx.setLineDash([Math.round(4 * dpr), Math.round(3 * dpr)]);
        ctx.beginPath();
        ctx.moveTo(Math.round(x), Math.round(capY));
        ctx.lineTo(Math.round(x + swatchW), Math.round(capY));
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        ctx.fillStyle = item.color;
        const sh = item.isCurrent ? swatchH + Math.round(1 * dpr) : swatchH;
        ctx.fillRect(Math.round(x), Math.round(capY - sh / 2), swatchW, sh);
      }
      x += swatchW + gap;
      ctx.fillStyle = dark ? '#999' : '#777';
      if (item.isCurrent) ctx.font = `600 ${capFontSize}px system-ui, -apple-system, sans-serif`;
      else ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.tag, Math.round(x), capY);
      x += item.tw + itemGap;
      ctx.globalAlpha = 1.0;
    });
    ctx.textAlign = 'center';
  }

  ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;

  if (is10) {
    // 10y: season color swatches (dimmed if pinned and not this one)
    const items = ds.filter(d => !d._isLastK).map((d, i) => {
      const tag = d.label.replace('Winter ', '');
      const tw = ctx.measureText(tag).width;
      return { tag, tw, color: d._baseColor, isCurrent: !!d._isCurrent, dimmed: hasPins && !pinnedSets.has(i) };
    });
    const lastKDs = ds.find(d => d._isLastK);
    if (lastKDs) {
      const lkTag = 'Last k days';
      const lkTw = ctx.measureText(lkTag).width;
      items.push({ tag: lkTag, tw: lkTw, color: lastKDs._baseColor, isCurrent: false, isDashed: true, dimmed: false });
    }
    drawSwatchRow(items);
  } else if (hasPins) {
    // 50y with pins: show pinned season swatches + "N others" summary
    const pinnedItems = [];
    ds.forEach((d, i) => {
      if (d._isLastK || !pinnedSets.has(i)) return;
      const tag = d.label.replace('Winter ', '');
      const tw = ctx.measureText(tag).width;
      pinnedItems.push({ tag, tw, color: d._baseColor, isCurrent: !!d._isCurrent, dimmed: false });
    });
    const othersCount = ds.filter((d, i) => !d._isLastK && !pinnedSets.has(i)).length;
    if (othersCount > 0) {
      const suffix = `+ ${othersCount} others`;
      const stw = ctx.measureText(suffix).width;
      pinnedItems.push({ tag: suffix, tw: stw, color: dark ? '#555' : '#bbb', isCurrent: false, dimmed: true });
    }
    drawSwatchRow(pinnedItems);
  } else {
    // 50y no pins: gradient bar with year labels
    const histDs = ds.filter(d => !d._isLastK && !d._isCurrent);
    const barW = Math.round(200 * dpr);
    const barH = Math.round(4 * dpr);
    const barX = (totalW - barW) / 2;
    const barY = capY - barH / 2 - Math.round(3 * dpr);
    for (let px = 0; px < barW; px++) {
      const gi = Math.floor(px / barW * histDs.length);
      ctx.fillStyle = histDs[Math.min(gi, histDs.length - 1)]._baseColor;
      ctx.fillRect(barX + px, barY, 1, barH);
    }
    ctx.fillStyle = dark ? '#999' : '#777';
    ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;
    ctx.textBaseline = 'top';
    const labelY = barY + barH + Math.round(2 * dpr);
    ctx.textAlign = 'left';
    ctx.fillText(histDs[0].label.replace('Winter ', ''), barX, labelY);
    ctx.textAlign = 'right';
    ctx.fillText(histDs[histDs.length - 1].label.replace('Winter ', ''), barX + barW, labelY);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
  }

  // Footer
  const footSize = Math.round(9 * dpr);
  ctx.font = `${footSize}px system-ui, -apple-system, sans-serif`;
  ctx.fillStyle = dark ? '#666' : '#999';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const genDate = new Date().toLocaleDateString();
  const genTime = new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', timeZoneName: 'short' });
  ctx.fillText(`Made by Cryofront, cooked with Claude by Johan Ugander. Generated ${genDate} at ${genTime}.`, totalW / 2, titleH + srcH + captionH + footerH / 2);

  // Download
  const link = document.createElement('a');
  const slug = lastLocationName.replace(/[^a-zA-Z0-9]+/g, '-').toLowerCase().replace(/-+$/, '');
  link.download = `cryofront-${numSeasons}y-${slug}.png`;
  link.href = c.toDataURL('image/png');
  link.click();
});

// ── Details modal ─────────────────────────────────────────────────────
const detailsModal = document.getElementById('details-modal');

document.getElementById('details-link').addEventListener('click', (e) => {
  e.preventDefault();
  detailsModal.style.display = '';
});

document.getElementById('details-backdrop').addEventListener('click', () => {
  detailsModal.style.display = 'none';
});

document.getElementById('details-close').addEventListener('click', () => {
  detailsModal.style.display = 'none';
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && detailsModal.style.display !== 'none') {
    detailsModal.style.display = 'none';
  }
});

</script>
</body>
</html>
