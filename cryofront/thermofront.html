<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Thermofront</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 36'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%23ff8c42'/%3E%3Cstop offset='100%25' stop-color='%23d64545'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cg stroke='url(%23g)' stroke-linecap='round' fill='none'%3E%3Cg stroke-width='2.8'%3E%3Cline x1='16' y1='2' x2='16' y2='18'/%3E%3Cline x1='16' y1='2' x2='11.8' y2='7'/%3E%3Cline x1='16' y1='2' x2='20.2' y2='7'/%3E%3Cline x1='16' y1='9' x2='12.8' y2='12'/%3E%3Cline x1='16' y1='9' x2='19.2' y2='12'/%3E%3C/g%3E%3Ccircle cx='16' cy='24' r='5' stroke='url(%23g)' stroke-width='2.2' fill='url(%23g)'/%3E%3Cg stroke-width='2.2'%3E%3Cline x1='3' y1='24' x2='8.5' y2='24'/%3E%3Cline x1='23.5' y1='24' x2='29' y2='24'/%3E%3Cline x1='7.3' y1='17.3' x2='11.3' y2='20'/%3E%3Cline x1='24.7' y1='17.3' x2='20.7' y2='20'/%3E%3Cline x1='7.3' y1='30.7' x2='11.3' y2='28'/%3E%3Cline x1='24.7' y1='30.7' x2='20.7' y2='28'/%3E%3Cline x1='16' y1='31.5' x2='16' y2='34'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E">
<meta name="description" content="The Pareto frontier of sustained heat — explore maximin temperature curves by city or ZIP code.">
<meta name="theme-color" content="#d64545">
<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="Thermofront">
<meta property="og:description" content="The Pareto frontier of sustained heat — explore maximin temperature curves by city or ZIP code.">
<meta property="og:image" content="https://jugander.github.io/cryofront/og-image-thermo.png">
<meta property="og:url" content="https://jugander.github.io/cryofront/thermofront.html">
<!-- Twitter / Bluesky -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Thermofront">
<meta name="twitter:description" content="The Pareto frontier of sustained heat — explore maximin temperature curves by city or ZIP code.">
<meta name="twitter:image" content="https://jugander.github.io/cryofront/og-image-thermo.png">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

/* --- Theme variables --- */

:root {
  --bg: #1a1a2e;
  --bg-card: #16213e;
  --text: #e0e0e0;
  --text-heading: #f0f0f0;
  --text-muted: #888;
  --text-card: #aaa;
  --text-card-strong: #ccc;
  --input-bg: #16213e;
  --input-border: #333;
  --input-text: #f0f0f0;
  --input-placeholder: #666;
  --accent: #e8652b;
  --accent-hover: #ff7b3a;
  --footer-text: #666;
  --footer-link: #888;
  --footer-link-hover: #aaa;
  --spinner-color: #f0c040;
  --status-loading: #f0c040;
  --status-error: #ff6b6b;
  --location-color: #e8e8e8;
}

html.light {
  --bg: #f4f4f8;
  --bg-card: #ffffff;
  --text: #333;
  --text-heading: #1a1a2e;
  --text-muted: #777;
  --text-card: #666;
  --text-card-strong: #444;
  --input-bg: #ffffff;
  --input-border: #ccc;
  --input-text: #333;
  --input-placeholder: #999;
  --accent: #c95420;
  --accent-hover: #a84218;
  --footer-text: #999;
  --footer-link: #777;
  --footer-link-hover: #555;
  --spinner-color: #c89b00;
  --status-loading: #b08800;
  --status-error: #d33;
  --location-color: #222;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

#app {
  max-width: 920px;
  margin: 0 auto;
  padding: 2rem 1rem;
}

header {
  text-align: center;
  margin-bottom: 2rem;
  position: relative;
}

header h1 {
  font-size: 2.2rem;
  font-weight: 300;
  letter-spacing: 0.05em;
  color: var(--text-heading);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.45rem;
}

.logo-icon {
  width: 1.6em;
  height: 1.6em;
  flex-shrink: 0;
}

header .subtitle {
  margin-top: 0.4rem;
  font-size: 0.9rem;
  color: var(--text-muted);
  font-style: italic;
}

/* --- Slide toggles --- */

.slide-toggle {
  display: inline-flex;
  align-items: center;
  border: 1px solid var(--input-border);
  border-radius: 20px;
  background: var(--input-bg);
  cursor: pointer;
  padding: 2px;
  position: relative;
  transition: border-color 0.2s, background 0.3s;
  user-select: none;
}

.slide-toggle:hover { border-color: var(--accent); }

.slide-toggle .opt {
  position: relative;
  z-index: 1;
  padding: 0.25rem 0.55rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  transition: color 0.25s;
  line-height: 1;
}

.slide-toggle .opt.active { color: var(--text-heading); }

.slide-toggle .slider {
  position: absolute;
  top: 2px;
  bottom: 2px;
  border-radius: 16px;
  background: var(--accent);
  opacity: 0.25;
  transition: left 0.25s ease, width 0.25s ease;
  pointer-events: none;
}

#theme-toggle-wrap {
  position: absolute;
  top: 0;
  right: 0;
}

/* --- Input --- */

#zip-form {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

#checkbox-row {
  flex-basis: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.75rem;
}

#loc-wrap {
  position: relative;
}

#loc-input {
  width: 240px;
  padding: 0.6rem 1rem;
  font-size: 1rem;
  border: 1px solid var(--input-border);
  border-radius: 8px;
  background: var(--input-bg);
  color: var(--input-text);
  outline: none;
  transition: border-color 0.2s, background 0.3s, color 0.3s;
}

#loc-input:focus {
  border-color: var(--accent);
}

#loc-input::placeholder {
  color: var(--input-placeholder);
}

#zip-form label {
  font-size: 0.82rem;
  font-weight: 600;
  color: var(--text-muted);
  white-space: nowrap;
}

#lastk-label {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

#lastk-label input {
  margin: 0;
  accent-color: var(--accent);
}

#incl-current-label {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

#incl-current-label input {
  margin: 0;
  accent-color: var(--accent);
}

#incl-today-label {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.78rem;
  font-weight: 600;
  color: var(--text-muted);
  cursor: pointer;
  white-space: nowrap;
  user-select: none;
}

#incl-today-label input {
  margin: 0;
  accent-color: var(--accent);
}

#loc-suggestions {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 4px;
  list-style: none;
  background: var(--bg-card);
  border: 1px solid var(--input-border);
  border-radius: 8px;
  overflow: hidden;
  z-index: 10;
  box-shadow: 0 4px 16px rgba(0,0,0,0.25);
}

#loc-suggestions li {
  padding: 0.5rem 0.8rem;
  font-size: 0.88rem;
  color: var(--text);
  cursor: pointer;
  transition: background 0.15s;
}

#loc-suggestions li:hover,
#loc-suggestions li.active {
  background: var(--accent);
  color: #fff;
}

#loc-suggestions li .loc-sub {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-left: 0.3rem;
}

#loc-suggestions li:hover .loc-sub,
#loc-suggestions li.active .loc-sub {
  color: rgba(255,255,255,0.7);
}

#go-btn {
  padding: 0.6rem 1.4rem;
  font-size: 1rem;
  font-weight: 600;
  border: none;
  border-radius: 8px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  transition: background 0.2s, opacity 0.2s;
}

#go-btn:hover { background: var(--accent-hover); }
#go-btn:disabled { opacity: 0.4; cursor: not-allowed; }


/* --- Status --- */

#status-area {
  text-align: center;
  min-height: 1.4rem;
  font-size: 0.9rem;
  margin-bottom: 1rem;
}

#status-area.loading { color: var(--status-loading); }
#status-area.error { color: var(--status-error); }

.spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--spinner-color);
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.7s linear infinite;
  vertical-align: middle;
  margin-right: 0.4rem;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* --- Chart --- */

#chart-container {
  background: var(--bg-card);
  border-radius: 12px;
  padding: 1.5rem 1rem 1rem;
  margin-top: 0.5rem;
  transition: background 0.3s;
}

#location-name {
  text-align: center;
  font-size: 1.3rem;
  font-weight: 400;
  color: var(--location-color);
  margin-bottom: 1rem;
}

#chart-wrapper {
  position: relative;
  width: 100%;
}

/* --- Chart legend --- */

#chart-legend {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 0.1rem 0.7rem;
  margin-top: 0.5rem;
  padding: 0 0.5rem;
}

#chart-legend .leg-item {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  font-size: 0.68rem;
  color: var(--text-muted);
  opacity: 0.7;
  cursor: pointer;
  user-select: none;
  transition: opacity 0.15s;
}

#chart-legend .leg-item:hover {
  opacity: 1;
}

#chart-legend .leg-item.pinned {
  opacity: 1;
  font-weight: 600;
}

#chart-legend .leg-swatch {
  width: 14px;
  height: 3px;
  border-radius: 1px;
}

#chart-legend .leg-item.current .leg-swatch {
  height: 4px;
}

#chart-legend .leg-item.pinned .leg-swatch {
  height: 5px;
}

/* When pins are active, dim unpinned items — including .current */
#chart-legend.has-pins .leg-item:not(.pinned) {
  opacity: 0.35;
  font-weight: 400;
}

#chart-legend.has-pins .leg-item:not(.pinned) .leg-swatch {
  height: 3px;
}

#chart-legend.grid-mode {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 0px 0.55rem;
  margin-top: 0.4rem;
  padding: 0 0.25rem;
  line-height: 1.25;
}

#chart-legend.grid-mode .leg-cell {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  font-size: 0.68rem;
  color: var(--text-muted);
  cursor: pointer;
  opacity: 0.65;
  transition: opacity 0.15s;
  user-select: none;
}

#chart-legend.grid-mode .leg-cell .leg-dot {
  width: 8px;
  height: 8px;
  border-radius: 1px;
  flex-shrink: 0;
}

#chart-legend.grid-mode .leg-cell:hover {
  opacity: 1;
}

#chart-legend.grid-mode .leg-cell.pinned {
  opacity: 1;
  font-weight: 700;
}

#chart-legend.grid-mode .leg-cell.pinned .leg-dot {
  outline: 1.5px solid var(--text);
  outline-offset: 0.5px;
}

#chart-legend.grid-mode .leg-cell.current {
  opacity: 1;
  font-weight: 700;
}

#chart-legend.grid-mode .leg-cell.current .leg-dot {
  outline: 1.5px solid var(--text);
  outline-offset: 0.5px;
}

/* When pins are active, dim unpinned cells — including .current */
#chart-legend.grid-mode.has-pins .leg-cell:not(.pinned) {
  opacity: 0.35;
  font-weight: 400;
}

#chart-legend.grid-mode.has-pins .leg-cell:not(.pinned) .leg-dot {
  outline: none;
}

#export-btn {
  display: block;
  margin: 0.5rem auto 0;
  padding: 0.25rem 0.65rem;
  font-size: 0.72rem;
  border: 1px solid var(--input-border);
  border-radius: 6px;
  background: var(--input-bg);
  color: var(--text-muted);
  cursor: pointer;
  opacity: 0.45;
  transition: opacity 0.2s, border-color 0.2s;
}
#export-btn:hover { opacity: 1; border-color: var(--accent); }

/* --- Stats box --- */

#stats-box {
  margin-top: 1.5rem;
  padding: 1rem 1.25rem;
  background: var(--bg-card);
  border-radius: 12px;
  color: var(--text-card);
  font-size: 0.85rem;
  line-height: 1.7;
  transition: background 0.3s;
}

#stats-box strong { color: var(--text-card-strong); }

#stats-box ul {
  list-style: disc;
  padding-left: 1.25rem;
  margin: 0.3rem 0 0;
}

/* --- Explanation --- */

#explanation {
  text-align: center;
  margin-top: 1.5rem;
  padding: 1rem;
  background: var(--bg-card);
  border-radius: 12px;
  color: var(--text-card);
  font-size: 0.85rem;
  line-height: 1.6;
  transition: background 0.3s;
}

#explanation strong { color: var(--text-card-strong); }
#explanation a { color: var(--accent); text-decoration: none; }
#explanation a:hover { color: var(--accent-hover); text-decoration: underline; }

#data-time {
  font-size: 0.78rem;
  color: var(--text-muted);
  font-style: italic;
}

/* --- Crosslink --- */

.see-also {
  text-align: center;
  margin-top: 1.5rem;
  font-size: 0.7rem;
  color: var(--footer-text);
}

.see-also a {
  color: var(--footer-link);
  text-decoration: none;
}

.see-also a:hover { color: var(--footer-link-hover); text-decoration: underline; }

/* --- Footer --- */

footer {
  text-align: center;
  margin-top: 0.5rem;
  font-size: 0.75rem;
  color: var(--footer-text);
}

footer a {
  color: var(--footer-link);
  text-decoration: none;
}

footer a:hover { color: var(--footer-link-hover); text-decoration: underline; }

/* --- Details lightbox --- */

#details-link {
  color: var(--accent);
  text-decoration: none;
  margin-left: 0.3rem;
}
#details-link:hover { color: var(--accent-hover); text-decoration: underline; }

#details-modal {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
}

#details-backdrop {
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.55);
}

#details-card {
  position: relative;
  max-width: 600px;
  width: calc(100% - 2rem);
  max-height: calc(100vh - 4rem);
  overflow-y: auto;
  background: var(--bg-card);
  color: var(--text);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  line-height: 1.65;
  font-size: 0.88rem;
}

#details-card h3 {
  color: var(--text-heading);
  font-size: 1.15rem;
  font-weight: 600;
  margin-bottom: 1rem;
}

#details-card h4 {
  color: var(--text-card-strong);
  font-size: 0.92rem;
  font-weight: 600;
  margin-top: 1.2rem;
  margin-bottom: 0.4rem;
}

#details-card p {
  margin-bottom: 0.7rem;
  color: var(--text-card);
}

#details-card strong { color: var(--text-card-strong); }

#details-card code {
  font-size: 0.82rem;
  background: var(--bg);
  padding: 0.1rem 0.35rem;
  border-radius: 4px;
}

#details-card a { color: var(--accent); text-decoration: none; }
#details-card a:hover { color: var(--accent-hover); text-decoration: underline; }

#details-close {
  position: absolute;
  top: 0.75rem;
  right: 0.75rem;
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 1.5rem;
  line-height: 1;
  cursor: pointer;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  transition: color 0.15s, background 0.15s;
}
#details-close:hover { color: var(--text); background: rgba(128,128,128,0.15); }

/* --- Responsive --- */

@media (max-width: 600px) {
  #app { padding: 1rem 0.75rem; }
  header h1 { font-size: 1.6rem; }
  #zip-form label { font-size: 0.75rem; }
  #loc-input { width: 160px; font-size: 0.9rem; padding: 0.5rem 0.8rem; }
  #chart-container { padding: 1rem 0.5rem 0.5rem; border-radius: 8px; }
  #location-name { font-size: 1.1rem; }
  #theme-toggle .opt { font-size: 0.7rem; padding: 0.2rem 0.4rem; }
  #details-card { padding: 1.5rem 1rem; font-size: 0.84rem; }
  #explanation { font-size: 0.8rem; padding: 0.75rem; }
  #stats-box { font-size: 0.8rem; padding: 0.75rem 1rem; }
}
</style>
</head>
<body>

<div id="app">
  <header>
    <h1><svg class="logo-icon" viewBox="0 0 32 36" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="lg" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#ff8c42"/><stop offset="100%" stop-color="#d64545"/></linearGradient></defs><g stroke="url(#lg)" stroke-linecap="round" fill="none"><g stroke-width="2.8"><line x1="16" y1="2" x2="16" y2="18"/><line x1="16" y1="2" x2="11.8" y2="7"/><line x1="16" y1="2" x2="20.2" y2="7"/><line x1="16" y1="9" x2="12.8" y2="12"/><line x1="16" y1="9" x2="19.2" y2="12"/></g><circle cx="16" cy="24" r="5" stroke="url(#lg)" stroke-width="2.2" fill="url(#lg)"/><g stroke-width="2.2"><line x1="3" y1="24" x2="8.5" y2="24"/><line x1="23.5" y1="24" x2="29" y2="24"/><line x1="7.3" y1="17.3" x2="11.3" y2="20"/><line x1="24.7" y1="17.3" x2="20.7" y2="20"/><line x1="7.3" y1="30.7" x2="11.3" y2="28"/><line x1="24.7" y1="30.7" x2="20.7" y2="28"/><line x1="16" y1="31.5" x2="16" y2="34"/></g></g></svg>Thermofront</h1>
    <p class="subtitle">The Pareto frontier of sustained heat.</p>
    <div id="theme-toggle-wrap">
      <div class="slide-toggle" id="theme-toggle">
        <div class="slider"></div>
        <span class="opt" data-val="dark">Dark</span>
        <span class="opt" data-val="light">Light</span>
      </div>
    </div>
  </header>

  <form id="zip-form">
    <label for="loc-input">City/ZIP:</label>
    <div id="loc-wrap">
      <input type="text" id="loc-input" placeholder="ZIP code or city name" autocomplete="off" spellcheck="false">
      <ul id="loc-suggestions"></ul>
    </div>
    <button type="submit" id="go-btn">Go</button>
    <div class="slide-toggle" id="unit-toggle">
      <div class="slider"></div>
      <span class="opt" data-val="F">°F</span>
      <span class="opt" data-val="C">°C</span>
    </div>
    <div class="slide-toggle" id="range-toggle">
      <div class="slider"></div>
      <span class="opt" data-val="10">10 year</span>
      <span class="opt" data-val="50">50 year</span>
    </div>
    <div id="checkbox-row">
      <label id="lastk-label"><input type="checkbox" id="lastk-toggle"> Last <em>k</em> days</label>
      <label id="incl-current-label"><input type="checkbox" id="incl-current-toggle"> Include current</label>
      <label id="incl-today-label"><input type="checkbox" id="incl-today-toggle"> Include today so far</label>
    </div>
  </form>

  <div id="status-area"></div>

  <div id="chart-container" style="display:none;">
    <h2 id="location-name"></h2>
    <div id="chart-wrapper">
      <canvas id="thermofront-chart"></canvas>
    </div>
    <div id="chart-legend"></div>
    <button id="export-btn" title="Save as PNG">Save PNG</button>
  </div>

  <div id="stats-box" style="display:none;">
    <p id="stats-city"></p>
    <ul id="stats-list"></ul>
  </div>

  <div id="explanation">
    <strong>What is a thermofront?</strong> A <em>maximin curve</em> for summer heat:
    for each streak length <em>k</em>, find the warmest <em>k</em>-day window in the season
    and report its trough daily low. This is a
    <em>Pareto frontier</em> of heat&mdash;there was no longer warm streak without
    allowing a lower trough temperature during that season.
    Where a curve crosses <strong>68&deg;F</strong> (20&deg;C),
    that&rsquo;s how many consecutive
    <a href="https://en.wikipedia.org/wiki/Tropical_night" target="_blank" rel="noopener">tropical nights</a> occurred.
    The bold line is the current season (Oct&ndash;Sep).
    The dashed line (toggle &ldquo;Last <em>k</em> days&rdquo;) shows the
    trough low over the most recent <em>k</em> days&mdash;a snapshot of right now.
    <span id="data-time"></span>
    <a href="#" id="details-link">More details&hellip;</a>
  </div>

  <div id="details-modal" style="display:none;">
    <div id="details-backdrop"></div>
    <div id="details-card">
      <button id="details-close" aria-label="Close">&times;</button>
      <h3>How the Thermofront Works</h3>
      <p>
        Pick a number of days&mdash;say 7. Now look at every 7-day stretch during
        the summer and ask: what was the <em>lowest</em> temperature during that stretch?
        The thermofront finds the 7-day stretch where that low was as
        <em>high as possible</em>. That is the warmest week of summer, measured by how
        cool it got at its coolest.
      </p>
      <h4>The Pareto frontier</h4>
      <p>
        At <em>k</em>&thinsp;=&thinsp;1 the thermofront is simply the highest single-day
        low of the season. As <em>k</em> grows, the window must include more nights,
        inevitably catching a cooler one, so the curve drops.
        The thermofront traces every point where you cannot find a <em>longer</em>
        hot stretch without accepting a <em>lower</em> trough&mdash;the classic shape
        of a Pareto frontier.
      </p>
      <h4>Tropical nights</h4>
      <p>
        A <a href="https://en.wikipedia.org/wiki/Tropical_night" target="_blank" rel="noopener">tropical night</a>
        is one where the overnight low stays at or above
        <strong>20&thinsp;&deg;C</strong> (68&thinsp;&deg;F).
        Where the thermofront crosses that threshold, you can read off how many
        consecutive tropical nights occurred during the season.
      </p>
      <h4>Reading the chart</h4>
      <p>
        Each line is one season (Oct&ndash;Sep). The <strong>bold line</strong> is the
        current season, updating as new nights are recorded. Hover to see the exact
        date range of the warmest <em>k</em>-day window. A small
        &starf; marks a value that is the warmest in the displayed history.
      </p>
      <p>
        The <strong>dashed &ldquo;Last <em>k</em> days&rdquo;</strong> overlay shows the
        <em>minimum</em> daily low over the most recent <em>k</em> days. It is always
        at or <em>below</em> the current season&rsquo;s thermofront, since the thermofront
        cherry-picks the best window while &ldquo;last <em>k</em>&rdquo; is anchored to today.
      </p>
      <h4>Daily lows only</h4>
      <p>
        All computations use <strong>daily low temperatures</strong>&mdash;one
        value per day, representing the coolest temperature recorded that day (usually
        overnight). Hourly data is not used; the
        <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a>
        historical archive provides the daily minimum.
      </p>
      <h4>Seasons &amp; data</h4>
      <p>
        A season runs from October&nbsp;1 through September&nbsp;30.
        The current season&rsquo;s curve updates throughout the year as new days
        are added. When two equally warm streaks exist, the most recent one is
        shown&mdash;so an ongoing heat wave always appears.
      </p>
      <p>
        Daily low temperatures come from the
        <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a>
        historical archive.
      </p>
      <h4>Include current season</h4>
      <p>
        The current season (Oct&ndash;Sep) is often incomplete&mdash;summer
        may not have arrived yet, so its thermofront only reflects data so far.
        Uncheck this box to hide the current season and compare only
        complete historical seasons against each other. When unchecked,
        the bold &ldquo;current&rdquo; line disappears and records are
        computed across historical seasons only.
      </p>
      <h4>Include today so far</h4>
      <p>
        By default, data ends at yesterday&mdash;the most recent day with
        a final, complete daily low. Check this box to append today&rsquo;s
        <strong>observed low so far</strong>, computed from hourly
        temperatures recorded up to the most recent hour. Because the day
        is still in progress, today&rsquo;s low may drop further; the value
        updates each time you reload. This affects both the season curves
        and the &ldquo;Last <em>k</em> days&rdquo; overlay.
      </p>
    </div>
  </div>

  <div class="see-also">See also: <a href="index.html">[Cryofront]</a> <a href="teletherm.html">[Teletherm]</a></div>
  <footer>
    Last updated Feb 9, 2026. Cooked with Claude by Johan Ugander. Weather data by <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo.com</a>
    (<a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY 4.0</a>)
  </footer>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3/dist/chartjs-plugin-annotation.min.js"></script>
<script>
// =========================================================================
// Configuration
// =========================================================================

const CONFIG = {
  GEOCODING_URL: 'https://geocoding-api.open-meteo.com/v1/search',
  ARCHIVE_URL: 'https://archive-api.open-meteo.com/v1/archive',
  TIMEZONE: 'America/New_York',
  MAX_K: 42,
  CACHE_MAX_AGE_MS: 3600 * 1000,
};

let chartInstance = null;
let lastResults = null;    // for re-rendering on theme/unit change
let lastLocationName = '';
let useCelsius = false;
let numSeasons = 10;

// Cache both 10y and 50y results per location so toggling doesn't re-fetch
let cachedResults10 = null;
let cachedResults50 = null;
let cachedLocation = null;
let showLastK = false;
let includeCurrent = false;
let includeToday = false;
let lastObservedHour = null;
let lastKData = null;  // raw Fahrenheit values for "last k days" line

function toDisplay(f) { return useCelsius ? (f - 32) * 5 / 9 : f; }
function unitLabel() { return useCelsius ? '\u00b0C' : '\u00b0F'; }
function tropicalTemp() { return useCelsius ? 20 : 68; }

function isDark() { return !document.documentElement.classList.contains('light'); }

function theme() {
  const dark = isDark();
  return {
    currentLine: dark ? '#ffffff' : '#1a1a2e',
    axisText: dark ? '#888' : '#777',
    axisTitle: dark ? '#999' : '#666',
    grid: dark ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.08)',
    tropicalLine: dark ? 'rgba(200,200,200,0.5)' : 'rgba(100,100,100,0.4)',
    tropicalLabel: dark ? 'rgba(200,200,200,0.7)' : 'rgba(80,80,80,0.7)',
    dimAlpha: dark ? '50' : '40',   // hex alpha for non-highlighted on hover
    fadeAlpha: dark ? '99' : '73',   // hex alpha for historical lines at rest
  };
}

// =========================================================================
// Cache (localStorage)
// =========================================================================

function readCache(key, maxAgeMs) {
  try {
    const raw = localStorage.getItem('tf_' + key);
    if (!raw) return null;
    const entry = JSON.parse(raw);
    if (maxAgeMs != null) {
      if (Date.now() - entry.ts > maxAgeMs) return null;
    }
    return entry.d;
  } catch { return null; }
}

function writeCache(key, data) {
  try {
    localStorage.setItem('tf_' + key, JSON.stringify({ d: data, ts: Date.now() }));
  } catch { /* full or unavailable */ }
}

// =========================================================================
// Helpers
// =========================================================================

function isoDate(d) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

// =========================================================================
// Geocoding
// =========================================================================

function isZip(s) { return /^\d{5}$/.test(s); }

async function geocodeQuery(query) {
  const key = query.trim().toLowerCase();
  const cacheKey = `geo_${key}`;
  const cached = readCache(cacheKey);
  if (cached) return cached;

  const resp = await fetch(`${CONFIG.GEOCODING_URL}?name=${encodeURIComponent(query)}&count=10&language=en&format=json`);
  if (!resp.ok) throw new Error(`Geocoding failed (HTTP ${resp.status})`);
  const data = await resp.json();
  const results = data.results || [];

  const zip = isZip(query) ? query : null;

  // First pass: US result with matching postcode (if ZIP)
  if (zip) {
    for (const r of results) {
      if (r.country_code === 'US' && (r.postcodes || []).includes(zip)) {
        const loc = { name: `${r.name}, ${r.admin1 || ''}`, lat: r.latitude, lon: r.longitude };
        writeCache(cacheKey, loc);
        return loc;
      }
    }
  }
  // Fallback: first US result
  for (const r of results) {
    if (r.country_code === 'US') {
      const loc = { name: `${r.name}, ${r.admin1 || ''}`, lat: r.latitude, lon: r.longitude };
      writeCache(cacheKey, loc);
      return loc;
    }
  }
  // ZIP fallback: try Zippopotam.us when Open-Meteo has no US match
  if (zip) {
    try {
      const zResp = await fetch(`https://api.zippopotam.us/us/${zip}`);
      if (zResp.ok) {
        const zData = await zResp.json();
        if (zData.places && zData.places.length > 0) {
          const p = zData.places[0];
          const loc = {
            name: `${p['place name']}, ${p.state}`,
            lat: parseFloat(p.latitude),
            lon: parseFloat(p.longitude),
          };
          writeCache(cacheKey, loc);
          return loc;
        }
      }
    } catch (_) { /* fall through to error */ }
  }
  throw new Error(`No US location found for "${query}"`);
}

// Autocomplete search — returns array of {name, admin1, lat, lon}
async function geocodeSearch(query) {
  const resp = await fetch(`${CONFIG.GEOCODING_URL}?name=${encodeURIComponent(query)}&count=6&language=en&format=json`);
  if (!resp.ok) return [];
  const data = await resp.json();
  return (data.results || [])
    .filter(r => r.country_code === 'US')
    .slice(0, 5)
    .map(r => ({ name: r.name, admin1: r.admin1 || '', lat: r.latitude, lon: r.longitude }));
}

// Selected location from autocomplete (bypass geocoding on submit)
let selectedLoc = null;

// =========================================================================
// Seasons
// =========================================================================

function makeSummerSeasons(count, ref) {
  if (!ref) {
    ref = new Date();
    if (!includeToday) ref.setDate(ref.getDate() - 1);
  }
  const currentYear = ref.getMonth() >= 9 ? ref.getFullYear() : ref.getFullYear() - 1;
  const seasons = [];
  for (let y = currentYear - count + 1; y <= currentYear; y++) {
    const start = new Date(y, 9, 1);          // Oct 1
    const nomEnd = new Date(y + 1, 8, 30);    // Sep 30
    const end = nomEnd < ref ? nomEnd : ref;
    const label = `Summer ${y}-${String((y + 1) % 100).padStart(2, '0')}`;
    seasons.push({ label, start, end, year: y });
  }
  return seasons;
}

// =========================================================================
// Weather data
// =========================================================================

async function fetchTodayObservedLow(loc) {
  const lat = loc.lat.toFixed(4);
  const lon = loc.lon.toFixed(4);
  const cacheKey = `tl_${lat}_${lon}`;
  const cached = readCache(cacheKey, 15 * 60 * 1000); // 15-min cache
  if (cached !== null) return cached;

  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}` +
    `&hourly=temperature_2m&temperature_unit=fahrenheit` +
    `&timezone=${CONFIG.TIMEZONE}&past_hours=24&forecast_hours=0`;
  const resp = await fetch(url);
  if (!resp.ok) return null;
  const data = await resp.json();
  if (!data.hourly) return null;

  const todayStr = isoDate(new Date());
  const times = data.hourly.time;
  const temps = data.hourly.temperature_2m;
  let low = Infinity;
  let latestHour = null;
  for (let i = 0; i < times.length; i++) {
    if (times[i].startsWith(todayStr) && temps[i] !== null) {
      if (temps[i] < low) low = temps[i];
      latestHour = times[i];
    }
  }
  if (low === Infinity) return null;
  lastObservedHour = latestHour;
  writeCache(cacheKey, low);
  return low;
}

async function fetchDailyLows(loc, startDate, endDate) {
  const lat = loc.lat.toFixed(4);
  const lon = loc.lon.toFixed(4);
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  // If endDate is today and includeToday is on, fetch archive through yesterday
  // then append today's observed low from the Forecast API
  const endsToday = includeToday && isoDate(endDate) === isoDate(today);
  const archiveEnd = endsToday ? yesterday : endDate;

  const s = isoDate(startDate);
  const e = isoDate(archiveEnd);

  const cacheKey = `l_${lat}_${lon}_${s}_${e}`;
  const isRecent = archiveEnd >= yesterday;
  let temps = readCache(cacheKey, isRecent ? CONFIG.CACHE_MAX_AGE_MS : undefined);

  if (!temps) {
    const url = `${CONFIG.ARCHIVE_URL}?latitude=${lat}&longitude=${lon}` +
      `&start_date=${s}&end_date=${e}` +
      `&daily=temperature_2m_min&temperature_unit=fahrenheit` +
      `&timezone=${CONFIG.TIMEZONE}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Weather API error (HTTP ${resp.status})`);
    const data = await resp.json();
    if (!data.daily) throw new Error('Unexpected API response');

    temps = [];
    const rawTemps = data.daily.temperature_2m_min;
    for (let i = 0; i < rawTemps.length; i++) {
      if (rawTemps[i] !== null) temps.push(rawTemps[i]);
    }
    if (temps.length === 0) throw new Error('No temperature data available');

    writeCache(cacheKey, temps);
  }

  if (endsToday) {
    const todayLow = await fetchTodayObservedLow(loc);
    if (todayLow !== null) temps = [...temps, todayLow];
  }

  return temps;
}

// =========================================================================
// Thermofront computation
// =========================================================================

function computeThermofront(dailyLows) {
  const n = dailyLows.length;
  if (n === 0) return { k: [], v: [], starts: [] };

  const maxK = Math.min(CONFIG.MAX_K, n);
  const kValues = [];
  const thermoValues = [];
  const startIndices = [];  // index of best window start for each k

  for (let k = 1; k <= maxK; k++) {
    let maxOfMin = -Infinity;
    let bestStart = 0;
    for (let i = 0; i <= n - k; i++) {
      let wMin = Infinity;
      for (let j = i; j < i + k; j++) {
        if (dailyLows[j] < wMin) wMin = dailyLows[j];
      }
      if (wMin >= maxOfMin) { maxOfMin = wMin; bestStart = i; }
    }
    kValues.push(k);
    thermoValues.push(maxOfMin);
    startIndices.push(bestStart);
  }

  return { k: kValues, v: thermoValues, starts: startIndices };
}

// Trailing-window min: for each k, min of the last k values in the array
function computeLastK(dailyLows) {
  const n = dailyLows.length;
  const maxK = Math.min(CONFIG.MAX_K, n);
  const values = [];
  for (let k = 1; k <= maxK; k++) {
    let mn = Infinity;
    for (let j = n - k; j < n; j++) {
      if (dailyLows[j] < mn) mn = dailyLows[j];
    }
    values.push(mn);
  }
  return values;
}

// =========================================================================
// UI helpers
// =========================================================================

const statusEl = document.getElementById('status-area');
const chartContainer = document.getElementById('chart-container');
function showStatus(msg) {
  statusEl.className = 'loading';
  statusEl.innerHTML = '<span class="spinner"></span>' + msg;
}

function showError(msg) {
  statusEl.className = 'error';
  statusEl.textContent = msg;
}

function clearStatus() {
  statusEl.className = '';
  statusEl.innerHTML = '';
}

function showChart() { chartContainer.style.display = ''; }
function hideChart() { chartContainer.style.display = 'none'; }

// =========================================================================
// Chart rendering
// =========================================================================

const COLORS = [
  '#5b9bd5', '#ed7d31', '#70ad47', '#e84d60', '#9e7cc1',
  '#c17d56', '#e89ac7', '#a0a0a0', '#c4bd36', '#4fc1c9',
];

function hslToHex(h, s, l) {
  s /= 100; l /= 100;
  const a = s * Math.min(l, 1 - l);
  const f = n => {
    const k = (n + h / 30) % 12;
    const c = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * c).toString(16).padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`;
}

function gradient50Hex(index, total, dark) {
  const t = total <= 1 ? 0 : index / (total - 1);
  const hue = 220 * (1 - t);
  const sat = 65 + 15 * t;
  const lit = dark ? (55 + 10 * t) : (40 + 10 * t);
  return hslToHex(hue, sat, lit);
}

// ---- Nearest-line highlight plugin ----

let highlightIndex = -1; // -1 = no hover, use default (current season bold)
let hoverDataIdx = -1;   // x-axis data index under cursor
let hoverMouseX = 0;
let hoverMouseY = 0;
const pinnedSets = new Set(); // dataset indices pinned via legend clicks

const highlightPlugin = {
  id: 'highlightNearest',

  afterEvent(chart, args) {
    const evt = args.event;
    const hasPins = pinnedSets.size > 0;

    if (evt.type === 'mouseout') {
      if (highlightIndex !== -1 || hoverDataIdx !== -1) {
        highlightIndex = -1;
        hoverDataIdx = -1;
        if (!hasPins) applyHighlight(chart, -1);
        args.changed = true;
      }
      return;
    }
    if (evt.type !== 'mousemove') return;

    const mouseY = evt.y;
    const mouseX = evt.x;
    hoverMouseX = mouseX;
    hoverMouseY = mouseY;
    const area = chart.chartArea;
    if (!area || mouseX < area.left || mouseX > area.right ||
        mouseY < area.top || mouseY > area.bottom) {
      if (highlightIndex !== -1 || hoverDataIdx !== -1) {
        highlightIndex = -1;
        hoverDataIdx = -1;
        if (!hasPins) applyHighlight(chart, -1);
        args.changed = true;
      }
      return;
    }

    // Find nearest data index by pixel x-distance
    const firstMeta = chart.getDatasetMeta(0);
    let dataIdx = 0;
    let bestXDist = Infinity;
    for (let i = 0; i < firstMeta.data.length; i++) {
      const dx = Math.abs(firstMeta.data[i].x - mouseX);
      if (dx < bestXDist) {
        bestXDist = dx;
        dataIdx = i;
      }
    }

    // Find nearest dataset by y-distance at this x index
    // When pins are active, only consider pinned datasets
    let nearest = -1;
    let nearestDist = Infinity;
    const datasets = chart.data.datasets;
    for (let i = 0; i < datasets.length; i++) {
      if (hasPins && !pinnedSets.has(i)) continue;
      const val = datasets[i].data[dataIdx];
      if (val == null) continue;
      const yPixel = chart.scales.y.getPixelForValue(val);
      const dist = Math.abs(yPixel - mouseY);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = i;
      }
    }

    const changed = nearest !== highlightIndex || dataIdx !== hoverDataIdx;
    hoverDataIdx = dataIdx;
    if (changed) {
      highlightIndex = nearest;
      if (!hasPins) applyHighlight(chart, nearest);
      args.changed = true;
    }
  },

  afterDraw(chart) {
    const area = chart.chartArea;
    const ctx = chart.ctx;
    const dark = isDark();
    const fontMain = '11px system-ui, sans-serif';
    const fontSub = '10px system-ui, sans-serif';

    // Info box for hovered (or nearest pinned) dataset
    const idx = highlightIndex;
    if (idx === -1 || hoverDataIdx === -1) return;
    const meta = chart.getDatasetMeta(idx);
    if (!meta.visible) return;
    const ds = chart.data.datasets[idx];

    const val = ds.data[hoverDataIdx];
    if (val == null) return;
    const pt = meta.data[hoverDataIdx];
    if (!pt) return;

    const k = hoverDataIdx + 1;
    const displayVal = val.toFixed(1);
    let line1, line2 = '';

    if (ds._isLastK) {
      line1 = `Last ${k}d  ${displayVal}${unitLabel()}`;
      const fmt = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      const endDay = new Date();
      const startDay = new Date();
      startDay.setDate(startDay.getDate() - k + 1);
      line2 = `${fmt(startDay)}\u2013${fmt(endDay)}`;
    } else {
      const seasonTag = ds.label.replace('Summer ', '');
      line1 = `${seasonTag}  ${k}d  ${displayVal}${unitLabel()}`;

      // Date range of the best k-day window
      if (ds._starts && ds._seasonStart && ds._starts[hoverDataIdx] != null) {
        const s0 = new Date(ds._seasonStart);
        const startDay = new Date(s0.getFullYear(), s0.getMonth(), s0.getDate() + ds._starts[hoverDataIdx]);
        const endDay = new Date(startDay.getFullYear(), startDay.getMonth(), startDay.getDate() + k - 1);
        const fmt = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        line2 = `${fmt(startDay)}\u2013${fmt(endDay)}`;
      }
      // Flag all-time low on the current season
      const isLow = ds._allTimeHigh && ds._allTimeHigh[hoverDataIdx];
      if (isLow) {
        const recLabel = `\u2605 ${numSeasons}y record`;
        line2 = line2 ? `${line2}  ${recLabel}` : recLabel;
      }
    }

    ctx.save();
    ctx.font = fontMain;
    const tw1 = ctx.measureText(line1).width;
    ctx.font = fontSub;
    const tw2 = line2 ? ctx.measureText(line2).width : 0;
    const pad = 5;
    const boxW = Math.max(tw1, tw2) + pad * 2;
    const lineH = 14;
    const boxH = line2 ? lineH * 2 + 4 : lineH + 6;
    // Position above the point, shift left if near right edge
    let bx = pt.x - boxW / 2;
    let by = pt.y - boxH - 8;
    if (bx < area.left) bx = area.left;
    if (bx + boxW > area.right) bx = area.right - boxW;
    if (by < area.top) by = pt.y + 8; // flip below if at top

    ctx.fillStyle = dark ? 'rgba(22,33,62,0.92)' : 'rgba(255,255,255,0.92)';
    ctx.strokeStyle = dark ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(bx, by, boxW, boxH, 4);
    ctx.fill();
    ctx.stroke();

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const cx = bx + boxW / 2;
    if (line2) {
      ctx.font = fontMain;
      ctx.fillStyle = dark ? '#eee' : '#333';
      ctx.fillText(line1, cx, by + lineH / 2 + 2);
      ctx.font = fontSub;
      ctx.fillStyle = dark ? '#aaa' : '#777';
      ctx.fillText(line2, cx, by + lineH + lineH / 2 + 2);
    } else {
      ctx.font = fontMain;
      ctx.fillStyle = dark ? '#eee' : '#333';
      ctx.fillText(line1, cx, by + boxH / 2);
    }
    ctx.restore();

    // Small dot on the data point
    ctx.save();
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = ds._baseColor || '#ffffff';
    ctx.fill();
    ctx.restore();
  },
};

function applyHighlight(chart, hoveredIdx) {
  const datasets = chart.data.datasets;
  const t = theme();
  const is50 = numSeasons === 50;
  const dark = isDark();
  const restAlpha = is50 ? (dark ? '45' : '30') : t.fadeAlpha;
  const restWidth = is50 ? 0.8 : 1.3;
  const hasPins = pinnedSets.size > 0;

  for (let i = 0; i < datasets.length; i++) {
    const ds = datasets[i];
    const isCurrent = !!ds._isCurrent;
    const isLastK = !!ds._isLastK;
    const isHovered = i === hoveredIdx;
    const isPinned = pinnedSets.has(i);
    if (isCurrent) ds._baseColor = t.currentLine;

    if (hasPins) {
      // Pinned mode: pinned datasets highlighted, everything else dimmed
      if (isPinned) {
        ds.borderColor = ds._baseColor;
        ds.borderWidth = 3;
      } else {
        ds.borderColor = ds._baseColor + (is50 ? (dark ? '28' : '18') : t.dimAlpha);
        ds.borderWidth = isLastK ? 1.5 : (is50 ? 0.6 : 1.1);
      }
    } else if (hoveredIdx === -1) {
      // No hover — default styling
      if (isCurrent) {
        ds.borderColor = t.currentLine;
        ds.borderWidth = 3.5;
      } else if (isLastK) {
        ds.borderColor = ds._baseColor;
        ds.borderWidth = 2.5;
      } else {
        ds.borderColor = ds._baseColor + restAlpha;
        ds.borderWidth = restWidth;
      }
    } else {
      if (isHovered) {
        ds.borderColor = ds._baseColor;
        ds.borderWidth = 3;
      } else {
        ds.borderColor = ds._baseColor + (is50 ? (dark ? '28' : '18') : t.dimAlpha);
        ds.borderWidth = isLastK ? 1.5 : (is50 ? 0.6 : 1.1);
      }
    }
  }
  chart.update('none');
}

// ---- Chart rendering ----

function renderChart(allResults, locationName) {
  const ctx = document.getElementById('thermofront-chart');
  const t = theme();

  if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
  highlightIndex = -1;

  // Store for re-render on theme change
  lastResults = allResults;
  lastLocationName = locationName;

  const labels = Array.from({ length: CONFIG.MAX_K }, (_, i) => i + 1);

  const fz = tropicalTemp();

  const is50 = numSeasons === 50;
  const dark = isDark();

  // Filter out current season if not included
  const displayResults = includeCurrent
    ? allResults
    : allResults.filter((_, i) => i < allResults.length - 1);
  if (displayResults.length === 0) return;

  const histCount = displayResults.length - 1;

  // Compute per-season records: for each season & k, is it the max across all displayed?
  const allRecords = displayResults.map((r, idx) => {
    const rec = new Array(CONFIG.MAX_K).fill(false);
    for (let ki = 0; ki < CONFIG.MAX_K; ki++) {
      const val = r.v[ki];
      if (val == null) continue;
      let isMax = true;
      for (let s = 0; s < displayResults.length; s++) {
        if (s === idx) continue;
        const other = displayResults[s].v[ki];
        if (other != null && other >= val) { isMax = false; break; }
      }
      rec[ki] = isMax;
    }
    return rec;
  });

  const datasets = displayResults.map((r, idx) => {
    const isCurrent = idx === displayResults.length - 1;
    const baseColor = isCurrent ? t.currentLine
      : is50 ? gradient50Hex(idx, histCount, dark) : COLORS[idx % COLORS.length];
    const displayData = r.v.slice(0, CONFIG.MAX_K).map(toDisplay);
    const ds = {
      label: r.season.label,
      data: displayData,
      _rawData: r.v.slice(0, CONFIG.MAX_K),
      _starts: r.starts ? r.starts.slice(0, CONFIG.MAX_K) : null,
      _seasonStart: r.season.start,
      _baseColor: baseColor,
      _allTimeHigh: allRecords[idx],
      borderColor: isCurrent ? t.currentLine
        : is50 ? baseColor + (dark ? '45' : '30') : baseColor + t.fadeAlpha,
      borderWidth: isCurrent ? 3.5 : (is50 ? 0.8 : 1.3),
      backgroundColor: 'transparent',
      pointRadius: 0,
      pointHitRadius: 8,
      tension: 0,
      order: isCurrent ? 0 : 1,
    };
    if (isCurrent) {
      ds._isCurrent = true;
    }
    return ds;
  });

  // "Last k days" overlay dataset
  if (showLastK && lastKData) {
    const lkColor = dark ? '#ff9f43' : '#d35400';
    const displayLK = lastKData.slice(0, CONFIG.MAX_K).map(toDisplay);
    datasets.push({
      label: 'Last k days',
      data: displayLK,
      _rawData: lastKData.slice(0, CONFIG.MAX_K),
      _baseColor: lkColor,
      _isLastK: true,
      borderColor: lkColor,
      borderWidth: 2.5,
      borderDash: [6, 3],
      backgroundColor: 'transparent',
      pointRadius: 0,
      pointHitRadius: 8,
      tension: 0,
      order: 0,
    });
  }

  document.getElementById('location-name').textContent = `Thermofront \u2014 ${locationName}`;

  chartInstance = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    plugins: [highlightPlugin],
    options: {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: window.innerWidth < 600 ? 4 / 3 : 5 / 3,
      interaction: { mode: 'nearest', axis: 'x', intersect: false },
      scales: {
        x: {
          title: { display: true, text: 'k (streak length in days)', color: t.axisTitle, font: { size: 12 } },
          ticks: {
            color: t.axisText,
            stepSize: 7,
            callback: (val) => val + 1,
          },
          afterBuildTicks(scale) {
            scale.ticks = [];
            for (let v = 7; v <= CONFIG.MAX_K; v += 7) {
              scale.ticks.push({ value: v - 1 });  // 0-based index into labels
            }
          },
          grid: { color: t.grid },
          min: 1,
          max: CONFIG.MAX_K,
        },
        y: {
          title: { display: true, text: `Temperature (${unitLabel()})`, color: t.axisTitle, font: { size: 12 } },
          ticks: { color: t.axisText },
          grid: { color: t.grid },
        },
      },
      plugins: {
        legend: { display: false },
        annotation: {
          annotations: {
            tropical: {
              type: 'line',
              yMin: fz, yMax: fz,
              borderColor: t.tropicalLine,
              borderWidth: 1,
              borderDash: [6, 4],
              label: {
                display: true,
                content: `${fz}${unitLabel()} (tropical night)`,
                position: 'start',
                color: t.tropicalLabel,
                font: { size: 11 },
                backgroundColor: 'transparent',
              },
            },
          },
        },
        tooltip: {
          enabled: false,
        },
      },
    },
  });

  // Clear any prior pins
  pinnedSets.clear();

  // Populate legend with click-to-pin
  const legendEl = document.getElementById('chart-legend');
  legendEl.innerHTML = '';

  const pinClickHandler = (dsIndex, el) => (e) => {
    e.stopPropagation();
    if (pinnedSets.has(dsIndex)) {
      pinnedSets.delete(dsIndex);
      el.classList.remove('pinned');
    } else {
      pinnedSets.add(dsIndex);
      el.classList.add('pinned');
    }
    // Toggle has-pins class on legend container
    legendEl.classList.toggle('has-pins', pinnedSets.size > 0);
    highlightIndex = -1;
    hoverDataIdx = -1;
    applyHighlight(chartInstance, -1);
  };

  if (is50) {
    // 50y: compact labeled cells
    legendEl.className = 'grid-mode';
    datasets.forEach((ds, dsIndex) => {
      if (ds._isLastK) return;
      const cell = document.createElement('span');
      cell.className = 'leg-cell' + (ds._isCurrent ? ' current' : '');
      // Short label: "75–76" from "Winter 1975-76"
      const tag = ds.label.replace('Summer ', '').replace(/\d{2}(\d{2})-(\d{2})/, '$1\u2013$2');
      cell.innerHTML = `<span class="leg-dot" style="background:${ds._baseColor}"></span>${tag}`;
      cell.title = ds.label;
      cell.addEventListener('click', pinClickHandler(dsIndex, cell));
      // Hover preview: highlight line on chart without pinning
      cell.addEventListener('mouseenter', () => {
        if (pinnedSets.size === 0) {
          highlightIndex = dsIndex;
          applyHighlight(chartInstance, dsIndex);
        }
      });
      cell.addEventListener('mouseleave', () => {
        if (pinnedSets.size === 0) {
          highlightIndex = -1;
          applyHighlight(chartInstance, -1);
        }
      });
      legendEl.appendChild(cell);
    });
  } else {
    // 10y: named color swatches
    legendEl.className = '';
    datasets.forEach((ds, dsIndex) => {
      if (ds._isLastK) return;
      const span = document.createElement('span');
      span.className = 'leg-item' + (ds._isCurrent ? ' current' : '');
      const tag = ds.label.replace('Summer ', '');
      span.innerHTML = `<span class="leg-swatch" style="background:${ds._baseColor}"></span>${tag}`;
      span.addEventListener('click', pinClickHandler(dsIndex, span));
      legendEl.appendChild(span);
    });
  }

  // Click on chart canvas clears all pins
  const canvas = document.getElementById('thermofront-chart');
  canvas.onclick = (e) => {
    if (pinnedSets.size > 0) {
      pinnedSets.clear();
      legendEl.querySelectorAll('.pinned').forEach(el => el.classList.remove('pinned'));
      legendEl.classList.remove('has-pins');
      highlightIndex = -1;
      hoverDataIdx = -1;
      applyHighlight(chartInstance, -1);
    }
  };
}

// =========================================================================
// Tropical-night statistics
// =========================================================================

function updateStats(allResults, locationName) {
  const statsBox = document.getElementById('stats-box');
  const statsCity = document.getElementById('stats-city');
  const statsList = document.getElementById('stats-list');
  const fmtShort = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  const fmtWithYear = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

  // 1. Current tropical night streak (from lastKData)
  let currentStreak = 0;
  if (lastKData) {
    for (let k = 1; k <= lastKData.length; k++) {
      if (lastKData[k - 1] >= 68) currentStreak = k;
      else break;
    }
  }

  // Helper: find longest tropical night streak for a season result
  function longestTropicalStreak(r) {
    let best = 0;
    for (let k = 1; k <= r.v.length; k++) {
      if (r.v[k - 1] >= 68) best = k;
      else break;
    }
    return best;
  }

  // Helper: compute date range for a streak
  function streakDates(r, k) {
    const s0 = new Date(r.season.start);
    const startDay = new Date(s0.getFullYear(), s0.getMonth(), s0.getDate() + r.starts[k - 1]);
    const endDay = new Date(startDay.getFullYear(), startDay.getMonth(), startDay.getDate() + k - 1);
    return { startDay, endDay };
  }

  // 2. Longest streak this season
  const current = allResults[allResults.length - 1];
  const thisSeasonK = !includeCurrent ? 0 : longestTropicalStreak(current);

  // 3. Longest streak ever (across all seasons)
  const statsResults = !includeCurrent
    ? allResults.filter((_, i) => i < allResults.length - 1)
    : allResults;
  let allTimeK = 0;
  let allTimeResult = null;
  for (const r of statsResults) {
    const k = longestTropicalStreak(r);
    if (k > allTimeK) { allTimeK = k; allTimeResult = r; }
  }

  // Build bullets
  const bullets = [];

  // Bullet 1: current streak
  const dayWord = currentStreak === 1 ? 'day' : 'days';
  bullets.push(`The daily low has stayed above 68\u00b0F for: <strong>${currentStreak} ${dayWord}</strong>`);

  // Bullet 2: longest this season
  if (!includeCurrent) {
    bullets.push(`Longest tropical night stretch this season: <strong>N/A</strong> (excluded)`);
  } else if (thisSeasonK > 0) {
    const { startDay, endDay } = streakDates(current, thisSeasonK);
    const dayWord2 = thisSeasonK === 1 ? 'day' : 'days';
    bullets.push(`Longest tropical night stretch this season: <strong>${fmtShort(startDay)}\u2009\u2013\u2009${fmtShort(endDay)}</strong> (<strong>${thisSeasonK} ${dayWord2}</strong>)`);
  } else {
    bullets.push(`Longest tropical night stretch this season: <strong>N/A</strong>`);
  }

  // Bullet 3: longest since earliest season
  const sinceYear = allResults[0].season.year;
  if (allTimeK > 0 && allTimeResult) {
    const { startDay, endDay } = streakDates(allTimeResult, allTimeK);
    const dayWord3 = allTimeK === 1 ? 'day' : 'days';
    bullets.push(`Longest tropical night stretch (since ${sinceYear}): <strong>${fmtWithYear(startDay)}\u2009\u2013\u2009${fmtWithYear(endDay)}</strong> (<strong>${allTimeK} ${dayWord3}</strong>)`);
  } else {
    bullets.push(`Longest tropical night stretch (since ${sinceYear}): <strong>N/A</strong>`);
  }

  let throughStr;
  if (includeToday && lastObservedHour) {
    const hourDate = new Date(lastObservedHour);
    const dateStr = hourDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    const timeStr = hourDate.toLocaleTimeString('en-US', { hour: 'numeric', timeZoneName: 'short' });
    throughStr = `${dateStr}, ${timeStr}`;
  } else {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const dateStr = yesterday.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
    throughStr = `${dateStr} (yesterday)`;
  }
  statsCity.innerHTML = `For <strong>${locationName}</strong> through ${throughStr}:`;
  statsList.innerHTML = bullets.map(b => `<li>${b}</li>`).join('');
  statsBox.style.display = '';
}

// =========================================================================
// Main
// =========================================================================

async function fetchSeasonResults(location, count) {
  const seasons = makeSummerSeasons(count);
  let done = 0;

  const promises = seasons.map(async (season) => {
    const temps = await fetchDailyLows(location, season.start, season.end);
    done++;
    showStatus(`${location.name} \u2014 fetching weather data\u2026 (${done}/${seasons.length})`);
    const tc = computeThermofront(temps);
    return { season, k: tc.k, v: tc.v, starts: tc.starts };
  });

  const settled = await Promise.allSettled(promises);
  const results = settled.filter(s => s.status === 'fulfilled').map(s => s.value);
  if (results.length === 0) throw new Error('Could not retrieve weather data for any season.');
  return results;
}

document.getElementById('zip-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  closeSuggestions();
  const query = document.getElementById('loc-input').value.trim();

  if (!query) {
    showError('Enter a US ZIP code or city name.');
    return;
  }

  const goBtn = document.getElementById('go-btn');
  goBtn.disabled = true;
  hideChart();
  showStatus('Looking up location\u2026');

  try {
    let location;
    if (selectedLoc) {
      location = selectedLoc;
      selectedLoc = null;
    } else {
      location = await geocodeQuery(query);
    }
    showStatus(`${location.name} \u2014 fetching weather data\u2026`);

    const results = await fetchSeasonResults(location, numSeasons);

    // Fetch last-k-days data (last 42 days, regardless of season)
    const lkEnd = new Date();
    if (!includeToday) lkEnd.setDate(lkEnd.getDate() - 1);
    const lkStart = new Date(lkEnd);
    lkStart.setDate(lkStart.getDate() - (CONFIG.MAX_K - 1));
    const lkTemps = await fetchDailyLows(location, lkStart, lkEnd);
    lastKData = computeLastK(lkTemps);

    // Cache results
    cachedLocation = location;
    if (numSeasons === 10) cachedResults10 = results;
    else cachedResults50 = results;

    // Show data freshness timestamp in user's local timezone
    const dataEnd = new Date();
    if (!includeToday) dataEnd.setDate(dataEnd.getDate() - 1);
    const dateStr = dataEnd.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
    document.getElementById('data-time').textContent = includeToday
      ? `Data through ${dateStr} (today\u2019s low so far).`
      : `Data through ${dateStr}.`;

    clearStatus();
    showChart();
    renderChart(results, location.name);
    updateStats(results, location.name);

  } catch (err) {
    showError(err.message);
  } finally {
    goBtn.disabled = false;
  }
});

// Pre-fill with default ZIP
document.getElementById('loc-input').value = '06515';

// Auto-load from URL query parameter (?zip=...)
const urlZip = new URLSearchParams(window.location.search).get('zip');
if (urlZip) {
  document.getElementById('loc-input').value = urlZip;
  document.getElementById('zip-form').requestSubmit();
}

// =========================================================================
// Autocomplete
// =========================================================================

const locInput = document.getElementById('loc-input');
const sugList = document.getElementById('loc-suggestions');
let acTimer = null;
let acIdx = -1; // keyboard nav index

function closeSuggestions() {
  sugList.style.display = 'none';
  sugList.innerHTML = '';
  acIdx = -1;
}

function showSuggestions(items) {
  if (items.length === 0) { closeSuggestions(); return; }
  sugList.innerHTML = '';
  acIdx = -1;
  items.forEach((item, i) => {
    const li = document.createElement('li');
    li.innerHTML = `${item.name}<span class="loc-sub">${item.admin1}</span>`;
    li.addEventListener('mousedown', (e) => {
      e.preventDefault(); // don't blur input
      selectedLoc = { name: `${item.name}, ${item.admin1}`, lat: item.lat, lon: item.lon };
      locInput.value = `${item.name}, ${item.admin1}`;
      closeSuggestions();
      document.getElementById('zip-form').requestSubmit();
    });
    sugList.appendChild(li);
  });
  sugList.style.display = 'block';
}

locInput.addEventListener('input', () => {
  selectedLoc = null;
  clearTimeout(acTimer);
  const q = locInput.value.trim();
  // Only autocomplete for non-ZIP text >= 2 chars
  if (isZip(q) || q.length < 2) { closeSuggestions(); return; }
  acTimer = setTimeout(async () => {
    const results = await geocodeSearch(q);
    // Only show if input hasn't changed
    if (locInput.value.trim() === q) showSuggestions(results);
  }, 250);
});

locInput.addEventListener('keydown', (e) => {
  const items = sugList.querySelectorAll('li');
  if (!items.length) return;
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    acIdx = Math.min(acIdx + 1, items.length - 1);
    items.forEach((li, i) => li.classList.toggle('active', i === acIdx));
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    acIdx = Math.max(acIdx - 1, 0);
    items.forEach((li, i) => li.classList.toggle('active', i === acIdx));
  } else if (e.key === 'Enter' && acIdx >= 0) {
    e.preventDefault();
    items[acIdx].dispatchEvent(new MouseEvent('mousedown'));
  } else if (e.key === 'Escape') {
    closeSuggestions();
  }
});

locInput.addEventListener('blur', () => {
  // Small delay to allow mousedown on suggestion to fire first
  setTimeout(closeSuggestions, 150);
});

// =========================================================================
// Slide toggle helper
// =========================================================================

function updateSlider(toggle) {
  const opts = toggle.querySelectorAll('.opt');
  const slider = toggle.querySelector('.slider');
  const activeOpt = toggle.querySelector('.opt.active');
  if (!activeOpt) return;
  slider.style.left = activeOpt.offsetLeft + 'px';
  slider.style.width = activeOpt.offsetWidth + 'px';
}

// =========================================================================
// Theme toggle
// =========================================================================

const themeToggle = document.getElementById('theme-toggle');

function applyThemeState() {
  const val = isDark() ? 'dark' : 'light';
  themeToggle.querySelectorAll('.opt').forEach(o => {
    o.classList.toggle('active', o.dataset.val === val);
  });
  updateSlider(themeToggle);
}

// Default to light; restore saved preference if dark
if (localStorage.getItem('tf_theme') === 'dark') {
  document.documentElement.classList.remove('light');
} else {
  document.documentElement.classList.add('light');
}
applyThemeState();

themeToggle.addEventListener('click', () => {
  document.documentElement.classList.toggle('light');
  const mode = isDark() ? 'dark' : 'light';
  localStorage.setItem('tf_theme', mode);
  applyThemeState();
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
  }
});

// =========================================================================
// Unit toggle (°F / °C)
// =========================================================================

const unitToggle = document.getElementById('unit-toggle');

function applyUnitState() {
  const val = useCelsius ? 'C' : 'F';
  unitToggle.querySelectorAll('.opt').forEach(o => {
    o.classList.toggle('active', o.dataset.val === val);
  });
  updateSlider(unitToggle);
}

// Restore saved preference
if (localStorage.getItem('tf_unit') === 'C') {
  useCelsius = true;
}
applyUnitState();

unitToggle.addEventListener('click', () => {
  useCelsius = !useCelsius;
  localStorage.setItem('tf_unit', useCelsius ? 'C' : 'F');
  applyUnitState();
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
  }
});

// ── Range toggle (10y / 50y) ──────────────────────────────────────────
const rangeToggle = document.getElementById('range-toggle');

function applyRangeState() {
  const val = String(numSeasons);
  rangeToggle.querySelectorAll('.opt').forEach(o => {
    o.classList.toggle('active', o.dataset.val === val);
  });
  updateSlider(rangeToggle);
}

// Restore saved preference
if (localStorage.getItem('tf_range') === '50') {
  numSeasons = 50;
}
applyRangeState();

rangeToggle.addEventListener('click', async () => {
  numSeasons = numSeasons === 10 ? 50 : 10;
  localStorage.setItem('tf_range', String(numSeasons));
  applyRangeState();

  // No location loaded yet — nothing to re-render
  if (!cachedLocation) return;

  // Check cache first
  const cached = numSeasons === 10 ? cachedResults10 : cachedResults50;
  if (cached) {
    lastResults = cached;
    lastLocationName = cachedLocation.name;
    renderChart(cached, cachedLocation.name);
    updateStats(cached, cachedLocation.name);
    return;
  }

  // Need to fetch data for this range
  const goBtn = document.getElementById('go-btn');
  goBtn.disabled = true;
  hideChart();
  showStatus(`${cachedLocation.name} \u2014 fetching weather data\u2026`);

  try {
    const results = await fetchSeasonResults(cachedLocation, numSeasons);
    if (numSeasons === 10) cachedResults10 = results;
    else cachedResults50 = results;
    lastResults = results;
    lastLocationName = cachedLocation.name;
    clearStatus();
    showChart();
    renderChart(results, cachedLocation.name);
    updateStats(results, cachedLocation.name);
  } catch (err) {
    showError(err.message);
  } finally {
    goBtn.disabled = false;
  }
});

// ── "Last k days" checkbox ────────────────────────────────────────────
document.getElementById('lastk-toggle').addEventListener('change', (e) => {
  showLastK = e.target.checked;
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
  }
});

// ── "Include current season" checkbox ──────────────────────────────────
// Set dynamic label showing current season (e.g. "Include 25-26")
{
  const now = new Date();
  const cy = now.getMonth() >= 9 ? now.getFullYear() : now.getFullYear() - 1;
  const tag = `${String(cy % 100).padStart(2, '0')}-${String((cy + 1) % 100).padStart(2, '0')}`;
  const lbl = document.getElementById('incl-current-label');
  lbl.childNodes[lbl.childNodes.length - 1].textContent = ` Include ${tag}`;
}
// Default is unchecked (false) for thermofront; restore saved preference
const savedIncl = localStorage.getItem('tf_incl');
if (savedIncl !== null) {
  includeCurrent = savedIncl === 'true';
  document.getElementById('incl-current-toggle').checked = includeCurrent;
}

document.getElementById('incl-current-toggle').addEventListener('change', (e) => {
  includeCurrent = e.target.checked;
  localStorage.setItem('tf_incl', includeCurrent ? 'true' : 'false');
  const todayToggle = document.getElementById('incl-today-toggle');
  if (!includeCurrent) {
    includeToday = false;
    todayToggle.checked = false;
    todayToggle.disabled = true;
    localStorage.setItem('tf_today', 'false');
    cachedResults10 = null;
    cachedResults50 = null;
  } else {
    todayToggle.disabled = false;
  }
  if (lastResults) {
    renderChart(lastResults, lastLocationName);
    updateStats(lastResults, lastLocationName);
  }
});

// ── "Include today" checkbox ──────────────────────────────────────────
if (includeCurrent && localStorage.getItem('tf_today') === 'true') {
  includeToday = true;
  document.getElementById('incl-today-toggle').checked = true;
}
if (!includeCurrent) {
  document.getElementById('incl-today-toggle').disabled = true;
}

document.getElementById('incl-today-toggle').addEventListener('change', (e) => {
  includeToday = e.target.checked;
  localStorage.setItem('tf_today', includeToday ? 'true' : 'false');
  cachedResults10 = null;
  cachedResults50 = null;
  if (cachedLocation) {
    document.getElementById('zip-form').requestSubmit();
  }
});

// ── PNG export ────────────────────────────────────────────────────────
document.getElementById('export-btn').addEventListener('click', () => {
  if (!chartInstance) return;

  const src = chartInstance.canvas;
  const dpr = window.devicePixelRatio || 1;
  const srcW = src.width;
  const srcH = src.height;
  const dark = isDark();
  const is10 = numSeasons === 10;

  const titleH = Math.round(36 * dpr);
  const need50yBar = !is10 && pinnedSets.size === 0;
  const captionH = Math.round((need50yBar ? 30 : 22) * dpr);
  const footerH = Math.round(28 * dpr);
  const padX = Math.round(12 * dpr);
  const totalW = srcW + padX * 2;
  const totalH = srcH + titleH + captionH + footerH;

  const c = document.createElement('canvas');
  c.width = totalW;
  c.height = totalH;
  const ctx = c.getContext('2d');

  // Background
  ctx.fillStyle = dark ? '#16213e' : '#ffffff';
  ctx.fillRect(0, 0, totalW, totalH);

  // Title
  const titleSize = Math.round(15 * dpr);
  ctx.font = `400 ${titleSize}px system-ui, -apple-system, sans-serif`;
  ctx.fillStyle = dark ? '#e8e8e8' : '#222';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(`Thermofront \u2014 ${lastLocationName}`, totalW / 2, titleH / 2);

  // Chart
  ctx.drawImage(src, padX, titleH);

  // Caption area
  const ds = chartInstance.data.datasets;
  const capFontSize = Math.round(8.5 * dpr);
  const capY = titleH + srcH + captionH / 2;

  const hasPins = pinnedSets.size > 0;
  const swatchW = Math.round(14 * dpr);
  const swatchH = Math.round(3 * dpr);
  const gap = Math.round(6 * dpr);
  const itemGap = Math.round(12 * dpr);

  // Helper: draw a row of swatch+label items centered at capY
  function drawSwatchRow(items) {
    ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;
    let totalLegW = 0;
    items.forEach(item => { totalLegW += swatchW + gap + item.tw; });
    totalLegW += itemGap * Math.max(items.length - 1, 0);

    let x = (totalW - totalLegW) / 2;
    items.forEach((item) => {
      ctx.globalAlpha = item.dimmed ? 0.35 : 1.0;
      if (item.isDashed) {
        ctx.strokeStyle = item.color;
        ctx.lineWidth = Math.round(2 * dpr);
        ctx.setLineDash([Math.round(4 * dpr), Math.round(3 * dpr)]);
        ctx.beginPath();
        ctx.moveTo(Math.round(x), Math.round(capY));
        ctx.lineTo(Math.round(x + swatchW), Math.round(capY));
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        ctx.fillStyle = item.color;
        const sh = item.isCurrent ? swatchH + Math.round(1 * dpr) : swatchH;
        ctx.fillRect(Math.round(x), Math.round(capY - sh / 2), swatchW, sh);
      }
      x += swatchW + gap;
      ctx.fillStyle = dark ? '#999' : '#777';
      if (item.isCurrent) ctx.font = `600 ${capFontSize}px system-ui, -apple-system, sans-serif`;
      else ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.tag, Math.round(x), capY);
      x += item.tw + itemGap;
      ctx.globalAlpha = 1.0;
    });
    ctx.textAlign = 'center';
  }

  ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;

  if (is10) {
    // 10y: season color swatches (dimmed if pinned and not this one)
    const items = ds.filter(d => !d._isLastK).map((d, i) => {
      const tag = d.label.replace('Summer ', '');
      const tw = ctx.measureText(tag).width;
      return { tag, tw, color: d._baseColor, isCurrent: !!d._isCurrent, dimmed: hasPins && !pinnedSets.has(i) };
    });
    const lastKDs = ds.find(d => d._isLastK);
    if (lastKDs) {
      const lkTag = 'Last k days';
      const lkTw = ctx.measureText(lkTag).width;
      items.push({ tag: lkTag, tw: lkTw, color: lastKDs._baseColor, isCurrent: false, isDashed: true, dimmed: false });
    }
    drawSwatchRow(items);
  } else if (hasPins) {
    // 50y with pins: show pinned season swatches + "N others" summary
    const pinnedItems = [];
    ds.forEach((d, i) => {
      if (d._isLastK || !pinnedSets.has(i)) return;
      const tag = d.label.replace('Summer ', '');
      const tw = ctx.measureText(tag).width;
      pinnedItems.push({ tag, tw, color: d._baseColor, isCurrent: !!d._isCurrent, dimmed: false });
    });
    const othersCount = ds.filter((d, i) => !d._isLastK && !pinnedSets.has(i)).length;
    if (othersCount > 0) {
      const suffix = `+ ${othersCount} others`;
      const stw = ctx.measureText(suffix).width;
      pinnedItems.push({ tag: suffix, tw: stw, color: dark ? '#555' : '#bbb', isCurrent: false, dimmed: true });
    }
    drawSwatchRow(pinnedItems);
  } else {
    // 50y no pins: gradient bar with year labels
    const histDs = ds.filter(d => !d._isLastK && !d._isCurrent);
    const barW = Math.round(200 * dpr);
    const barH = Math.round(4 * dpr);
    const barX = (totalW - barW) / 2;
    const barY = capY - barH / 2 - Math.round(3 * dpr);
    for (let px = 0; px < barW; px++) {
      const gi = Math.floor(px / barW * histDs.length);
      ctx.fillStyle = histDs[Math.min(gi, histDs.length - 1)]._baseColor;
      ctx.fillRect(barX + px, barY, 1, barH);
    }
    ctx.fillStyle = dark ? '#999' : '#777';
    ctx.font = `${capFontSize}px system-ui, -apple-system, sans-serif`;
    ctx.textBaseline = 'top';
    const labelY = barY + barH + Math.round(2 * dpr);
    ctx.textAlign = 'left';
    ctx.fillText(histDs[0].label.replace('Summer ', ''), barX, labelY);
    ctx.textAlign = 'right';
    ctx.fillText(histDs[histDs.length - 1].label.replace('Summer ', ''), barX + barW, labelY);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
  }

  // Footer
  const footSize = Math.round(9 * dpr);
  ctx.font = `${footSize}px system-ui, -apple-system, sans-serif`;
  ctx.fillStyle = dark ? '#666' : '#999';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const genDate = new Date().toLocaleDateString();
  const genTime = new Date().toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', timeZoneName: 'short' });
  ctx.fillText(`Made by Thermofront, cooked with Claude by Johan Ugander. Generated ${genDate} at ${genTime}.`, totalW / 2, titleH + srcH + captionH + footerH / 2);

  // Download
  const link = document.createElement('a');
  const slug = lastLocationName.replace(/[^a-zA-Z0-9]+/g, '-').toLowerCase().replace(/-+$/, '');
  link.download = `thermofront-${numSeasons}y-${slug}.png`;
  link.href = c.toDataURL('image/png');
  link.click();
});

// ── Details modal ─────────────────────────────────────────────────────
const detailsModal = document.getElementById('details-modal');

document.getElementById('details-link').addEventListener('click', (e) => {
  e.preventDefault();
  detailsModal.style.display = '';
});

document.getElementById('details-backdrop').addEventListener('click', () => {
  detailsModal.style.display = 'none';
});

document.getElementById('details-close').addEventListener('click', () => {
  detailsModal.style.display = 'none';
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && detailsModal.style.display !== 'none') {
    detailsModal.style.display = 'none';
  }
});

</script>
</body>
</html>
